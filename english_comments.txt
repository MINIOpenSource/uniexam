File: app/admin_routes.py
Comment: # endregion (appears multiple times, e.g., after '模块导入')
Comment: # endregion (after '全局变量与初始化')
Comment: # payload is body, request is dependency (Line: async def admin_update_settings...)
Comment: # endregion (after 'Admin Settings API 端点')
Comment: # endregion (after 'Admin User Management API 端点')
Comment: # endregion (after 'Admin Paper Management API 端点')
Comment: # endregion (after 'Admin Question Bank Management API 端点')
Comment: # Admin Grading API (from line: # region Admin Grading API 端点 (管理员阅卷接口))
Comment: # endregion (after 'Admin Grading API 端点')
Comment: # endregion (after 'Admin Token Management API 端点')
Comment: # endregion (after 'Admin Audit Log Viewing API 端点')

---
File: app/core/__init__.py
Comment: # (Re-export specific important names for easier access directly from app.core)
Comment: # type: ignore (appears multiple times, e.g., after 'UserTag = security.UserTag')
Comment: # (If get_current_active_user is defined in security.py, then export it)
Comment: # (This is often a dependency for FastAPI routes.)
Comment: # get_current_active_user (from commented-out line: # get_current_active_user = security.get_current_active_user)
Comment: # (If declared in __all__ but not in security module, remove to avoid runtime import error)
Comment: # (Ensure all names in __all__ are actually available in the current module's global scope)

---
File: app/core/config.py
Comment: # (This module is responsible for defining the application's configuration models (using Pydantic), loading configuration items from .env files and JSON configuration files (settings.json), and providing a globally accessible configuration instance. It also includes functionality for dynamically generating the `DifficultyLevel` enum and setting up logging.) (Docstring)
Comment: # (Import asyncio for locks)
Comment: # (Import standard logging module)
Comment: # (Import logging handlers module)
Comment: # (Ensure Enum is imported)
Comment: # (For handling file paths)
Comment: # (Load environment variables from .env file)
Comment: # (Pydantic v2中推荐使用field_validator, 但validator在v1兼容模式下仍可使用)
Comment: # (Import custom enum type)
Comment: # (Custom log formatter that converts log records into JSON formatted strings.) (Class Docstring)
Comment: # (Formats a LogRecord object into a JSON string.) (Method Docstring)
Comment: # (Add exception information)
Comment: # (Add extra fields passed via extra)
Comment: # (Formatter可能添加的内部属性，以及我们已经明确记录的)
Comment: # (default=str 处理无法序列化的对象)
Comment: # (Reads and extracts unique 'id' values from the question bank index file (data/library/index.json) to dynamically create members for the `DifficultyLevel` enum. This function is called once when the module is loaded.) (Docstring)
Comment: # (A list of valid and unique difficulty IDs extracted from the index file. Returns an empty list if the file does not exist, is improperly formatted, or no valid IDs are found.) (Return part of Docstring)
Comment: # (Get current working directory and construct paths for data and library index files)
Comment: # (Question library directory name)
Comment: # (Question library index file name)
Comment: # (DifficultyLevel: Critical file '{index_json_path}' not found. Cannot dynamically create DifficultyLevel enum from library index.)
Comment: # (Load JSON data)
Comment: # (DifficultyLevel: Content of file '{index_json_path}' is not a list. Expected a list of question bank metadata items.)
Comment: # (ID should not be empty)
Comment: # (DifficultyLevel: Item at index {item_idx} in '{index_json_path}' has an empty 'id'. Skipped.)
Comment: # (ID must be a valid Python identifier)
Comment: # (DifficultyLevel: Item 'id' \"{item_id}\" in '{index_json_path}' is not a valid Python identifier. Cannot be used as enum member name. Skipped.)
Comment: # (Ensure uniqueness of ID)
Comment: # (If duplicate, log warning and use the first occurrence)
Comment: # (DifficultyLevel: Duplicate 'id' \"{item_id}\" found in '{index_json_path}'. Using the first occurrence.)
Comment: # (DifficultyLevel: Item at index {item_idx} in '{index_json_path}' is invalid or lacks a valid 'id' string: {str(item)[:100]}...)
Comment: # (If no valid IDs were collected in the end)
Comment: # (DifficultyLevel: Failed to find any valid and unique 'id' in '{index_json_path}' to create DifficultyLevel enum members.)
Comment: # (DifficultyLevel: Failed to decode JSON from '{index_json_path}': {e}. Cannot create dynamic DifficultyLevel enum.)
Comment: # (DifficultyLevel: IOError occurred while reading '{index_json_path}': {e}. Cannot create dynamic DifficultyLevel enum.)
Comment: # (Catch other unexpected errors)
Comment: # (Log full exception information)
Comment: # (Execute function to get difficulty IDs)
Comment: # (Dynamically create DifficultyLevel enum based on fetched IDs)
Comment: # (If failed to load any difficulty levels, log critical error and use a fallback enum)
Comment: # (CRITICAL ERROR: Cannot load any difficulty levels from library/index.json. Application functionality will be severely affected. Using a fallback DifficultyLevel with a single 'unknown_difficulty' member.)
Comment: # (Use fetched IDs to create enum members)
Comment: # (Successfully dynamically created DifficultyLevel enum, members)
Comment: # (Using AuthStatusCodeEnum enum to replace old string constants)
Comment: # (These status codes can be used by CRUD operations or other API endpoints as part of the response to provide more specific information about the execution result.)
Comment: # (Operation successful)
Comment: # (Resource not found)
Comment: # (Custom code for informational/specific conditions, not errors)
Comment: # (Rate limit configuration model for a single interface. Defines the maximum number of requests allowed within a specific time window.) (Docstring for RateLimitConfig)
Comment: # (Max requests in time window)
Comment: # (Time window size in seconds)
Comment: # (Collection of rate limit configurations for specific user types. Allows defining different interface rate limits for different user types (e.g., default user, limited user).) (Docstring for UserTypeRateLimits)
Comment: # (Rate limit for get_exam endpoint)
Comment: # (Rate limit for auth attempts (login/signup))
Comment: # (Configuration model for Cloudflare IP address range acquisition. Used to fetch the latest IP ranges from Cloudflare's official addresses to more accurately identify the real client IP for requests proxied through CF.) (Docstring for CloudflareIPsConfig)
Comment: # (Cloudflare IPv4 address range list URL)
Comment: # (Cloudflare IPv6 address range list URL)
Comment: # (Auto-update interval in seconds, default 24h)
Comment: # (Database file path configuration model (for file-based storage like JSON). Paths are relative to `data_dir`.) (Docstring for DatabaseFilesConfig)
Comment: # (Filename for paper data)
Comment: # (Filename for user data)
Comment: # (Validation rule configuration model for user registration. Defines length and format requirements for username and password.) (Docstring for UserValidationConfig)
Comment: # (Min username length)
Comment: # (Max username length)
Comment: # (Min password length)
Comment: # (Max password length)
Comment: # (Regex for username: lowercase letters, numbers, underscore)
Comment: # (Application Main Configuration Model) (Docstring for Settings)
Comment: # (Aggregates all application configuration items, including basic info, security settings, functional parameters, database connections, etc. Configuration items can be loaded from environment variables, JSON files, and have default values.) (Docstring for Settings)
Comment: # (Application name)
Comment: # (Main application domain)
Comment: # (Frontend domain for CORS)
Comment: # (Application listening port)
Comment: # (Initial admin password (optional, via env var for first run))
Comment: # (Token expiry in hours)
Comment: # (Byte length of generated token (string length is 2x))
Comment: # (Default questions per paper)
Comment: # (Number of correct choices to select (mainly for single choice))
Comment: # (Number of incorrect choices for multiple choice questions)
Comment: # (Byte length for random hex string for choice IDs & passcodes)
Comment: # (Passing score percentage)
Comment: # (Interval for persisting in-memory data to file (seconds))
Comment: # (Rate limit configs for different user types)
Comment: # (Cloudflare IP fetching config)
Comment: # (Log filename)
Comment: # (Application log level)
Comment: # (Audit log file path)
Comment: # (JSON database filename config)
Comment: # (Relative path for question library (to data_dir))
Comment: # (Question library index filename)
Comment: # (User validation rule config)
Comment: # (Data storage type)
Comment: # (PostgreSQL host)
Comment: # (PostgreSQL port)
Comment: # (PostgreSQL user)
Comment: # (PostgreSQL password)
Comment: # (PostgreSQL database name)
Comment: # (PostgreSQL DSN (overrides individual params))
Comment: # (MySQL host)
Comment: # (MySQL port)
Comment: # (MySQL user)
Comment: # (MySQL password)
Comment: # (MySQL database name)
Comment: # (Redis host)
Comment: # (Redis port)
Comment: # (Redis database number)
Comment: # (Redis password (optional))
Comment: # (Redis connection URL (overrides individual params))
Comment: # (SQLite database file path)
Comment: # (Base directory for application data files)
Comment: # (Enable Uvicorn access log)
Comment: # (Enable debug mode (mainly for uvicorn reload))
Comment: # (Validate user config: max length not less than min length.)
Comment: # (uid_max_len cannot be less than uid_min_len)
Comment: # (password_max_len cannot be less than password_min_len)
Comment: # (Pydantic v2+ handles enum validation automatically when the type hint is LogLevelEnum...)
Comment: # (Ensure validation on assignment)
Comment: # (Ignore extra fields not defined in the model)
Comment: # (Get the full path for a specific type of JSON database file.) (Docstring for get_db_file_path)
Comment: # (Database type, e.g., 'papers', 'users', 'settings'.)
Comment: # (Full Path object for the corresponding database file.)
Comment: # (If the requested `db_type` is unknown.)
Comment: # (settings.json usually directly under data_dir)
Comment: # (Unknown database file type)
Comment: # (Get the full path of the question library folder.)
Comment: # (Get the full path of the question library index file.)
Comment: # (Global singleton configuration instance)
Comment: # (Async lock for updating config file)
Comment: # (Configure application-wide logging. Sets up the root logger, adds console and file handlers.) (Docstring for setup_logging)
Comment: # (Log level string (e.g., "INFO", "DEBUG").)
Comment: # (Log filename.)
Comment: # (Data directory where log file will be stored.)
Comment: # (Application main logger configuration)
Comment: # (Get root logger)
Comment: # (Set root log level)
Comment: # (Remove existing handlers to prevent duplicate logging (especially on reload))
Comment: # (Keep original text formatter for console)
Comment: # (Create and set JSON formatter for file handler)
Comment: # (Use TimedRotatingFileHandler for daily log rotation, keep 7 backups)
Comment: # (Rotate at midnight)
Comment: # (Once a day)
Comment: # (Keep 7 backup files)
Comment: # (Use UTC for rotation)
Comment: # (Open file on handler creation)
Comment: # (Application logs will be written in daily rotated JSON format to)
Comment: # (Level)
Comment: # (Failed to configure rotating JSON log file handler)
Comment: # (Uvicorn logger configuration)
Comment: # (Uvicorn access log enabled and configured.)
Comment: # (Uvicorn access log disabled.)
Comment: # (Ensures that data files and directories required by the application exist. If they don't exist, it attempts to create them. This function is primarily called by `load_settings` after the initial configuration load.) (Docstring for _ensure_data_files_exist)
Comment: # (The current application configuration instance.)
Comment: # (Create main data directory)
Comment: # (Ensure user and paper JSON database files exist (if using JSON storage))
Comment: # (Initialize as empty list)
Comment: # (Hint: Created empty user database file at '{users_db_path}'.)
Comment: # (Hint: Created empty paper database file at '{papers_db_path}'.)
Comment: # (Ensure question library directory and index file exist)
Comment: # (Create empty JSON list)
Comment: # (Hint: Created empty question library index file at '{library_index_path}'.)
Comment: # (IOError creating data files/dirs)
Comment: # (Unknown error creating data files/dirs)
Comment: # (Load application configuration) (Docstring for load_settings)
Comment: # (Configuration loading order: Pydantic model defaults -> settings.json file -> environment variables. Environment variables have the highest priority. On first run, if settings.json doesn't exist, one will be generated based on defaults and environment variables. Logging configuration and basic data file existence are also ensured.) (Docstring for load_settings)
Comment: # (Loaded and validated global configuration instance.) (Return part of Docstring for load_settings)
Comment: # (If already loaded, return singleton)
Comment: # (Project root directory)
Comment: # (Data directory)
Comment: # (Main config file path)
Comment: # (Load .env file)
Comment: # (For config from settings.json)
Comment: # (Cannot load JSON config from '{settings_file}': {e}. Using defaults and env vars.)
Comment: # (JSON config file '{settings_file}' not found. Creating based on defaults and env vars.)
Comment: # (Pydantic V2 handles fields marked with `env` automatically. Manual merging here for clarity.)
Comment: # (Pydantic model field defaults are the base)
Comment: # (json_config overrides Pydantic defaults)
Comment: # (Environment variables override json_config and Pydantic defaults)
Comment: # (Start with JSON config, Pydantic handles defaults and env vars)
Comment: # (Pydantic validates and loads env vars here)
Comment: # (Application config loaded and validated successfully.)
Comment: # (Config validation failed! Using pure Pydantic model defaults.\nError details)
Comment: # (Fallback to pure Pydantic defaults on error)
Comment: # (Dynamically set data_dir)
Comment: # (Write config to settings.json, excluding sensitive or dynamically calculated fields)
Comment: # (DB connection info usually from env vars)
Comment: # (Hint: Base config written to '{settings_file}'. Modify as needed.)
Comment: # (Cannot write initial config to '{settings_file}')
Comment: # (Pass the enum's value)
Comment: # (Asynchronously updates and persists the application's configuration. It reads the current settings.json, merges new data, validates, and then writes back to settings.json. The global `_settings_instance` is also updated.) (Docstring for update_and_persist_settings)
Comment: # (A dictionary containing configuration items to update. Keys should match field names in the `Settings` model.)
Comment: # (The updated and reloaded global configuration instance.)
Comment: # (If the provided configuration data is invalid.)
Comment: # (If writing to settings.json file fails.)
Comment: # (Ensure config is loaded first)
Comment: # (Use async lock for atomic file ops)
Comment: # (Failed to read current settings.json: {e}. Updating based on empty config.)
Comment: # (Merge new data into config loaded from file)
Comment: # (Pydantic V2: Env vars handled at instantiation, focus on data persisted to JSON)
Comment: # (Data validation failed on update)
Comment: # (Provided config data invalid)
Comment: # (Update global instance)
Comment: # (App config updated and written to '{settings_file_path}'.)
Comment: # (Failed to update config file)
Comment: # (Load config once on module load)
Comment: # (Global settings instance)
Comment: # (Settings Pydantic model class)
Comment: # (DifficultyLevel enum)
Comment: # (RateLimitConfig model)
Comment: # (UserTypeRateLimits model)
Comment: # (CloudflareIPsConfig model)
Comment: # (DatabaseFilesConfig model)
Comment: # (UserValidationConfig model)
Comment: # (Logging setup function)
Comment: # (Settings loading function)
Comment: # (Settings update function)
Comment: # (Auth status codes)
Comment: # (General API status codes)
Comment: # (This module should not be executed as the main script. It defines configuration models and loading logic, and should be imported by other parts of the application.)

---
File: app/core/interfaces.py
Comment: # (No specific English line comments identified for this file beyond docstrings)

---
File: app/core/rate_limiter.py
Comment: # (This module provides rate limiting functionality based on IP address and operation type. It uses in-memory lists of timestamps to track request frequency and applies limits based on rules defined in the configuration file. The main function is `is_rate_limited`, used to check if a specific request should be blocked.) (Docstring)
Comment: # (Module Imports) (from '# region 模块导入 (Module Imports)')
Comment: # (Import FastAPI's Request object) (from '# 导入FastAPI的Request对象 (Import FastAPI's Request object)')
Comment: # (可选) 如需基于用户标签的速率限制 (English part of: # from .security import get_current_user_info_from_token # (可选) 如需基于用户标签的速率限制)
Comment: # (Global Variables & Initialization) (from '# region 全局变量与初始化 (Global Variables & Initialization)')
Comment: # (Data structures for rate limiting) (from '# 用于速率限制的数据结构: (Data structures for rate limiting)')
Comment: # (Key is IP address (str), value is a list of request timestamps (List[float]) for the corresponding action)
Comment: # (Store rate limit data for different actions separately) (from '# 分开存储不同操作的速率限制数据 (Store rate limit data for different actions separately)')
Comment: # "get_exam" action (from '# 获取新试卷 ("get_exam" action)')
Comment: # "auth_attempts" action (from '# 登录/注册等认证尝试 ("auth_attempts" action)')
Comment: # (Rate Limiting Core Logic) (from '# region 速率限制核心逻辑 (Rate Limiting Core Logic)')
Comment: # (e.g., "get_exam", "auth_attempts") (from '# 例如 "get_exam", "auth_attempts" (e.g., "get_exam", "auth_attempts")')
Comment: # (Checks if the specified IP and action type have exceeded the rate limit.) (Docstring of is_rate_limited)
Comment: # (Client's IP address.) (Docstring of is_rate_limited)
Comment: # (Action type, used to find corresponding limit rules in config.) (Docstring of is_rate_limited)
Comment: # ((Optional) List of current user's tags, for applying user-type-specific limits.) (Docstring of is_rate_limited)
Comment: # (True if the request should be limited, False otherwise.) (Docstring of is_rate_limited)
Comment: # (Determine which set of rate limit rules to use based on user tags)
Comment: # (Defaults to "default_user"; if user has "limited" tag, use "limited_user")
Comment: # (Admins are typically not rate-limited (this check should be done before calling this function))
Comment: # (Get rate limit config for the action type from settings)
Comment: # (Rate limit config not found for user type '{limit_config_key}'. Defaulting to no limit.)
Comment: # (Configuration error, default to no limit) (from '# 配置错误，默认不限制 (Configuration error, default to no limit)')
Comment: # (Rate limit config not found for action '{action_type}' in user type '{limit_config_key}'. Defaulting to no limit.)
Comment: # (Select the timestamp dictionary for the corresponding action)
Comment: # Unknown rate limit action type (from '# 未知的速率限制操作类型 (Unknown rate limit action type): {action_type}。默认不限制。')
Comment: # (Remove all old timestamps earlier than (current_time - window_period))
Comment: # (action_limit_config.window is in seconds) (from '# action_limit_config.window 是秒数 (action_limit_config.window is in seconds)')
Comment: # (Limit reached or exceeded) (from '# 已达到或超过限制 (Limit reached or exceeded)')
Comment: # (Update with cleaned list (optional)) (from '# 更新为清理后的列表（可选）(Update with cleaned list (optional))')
Comment: # (Should be limited) (from '# 应被限制 (Should be limited)')
Comment: # (Not exceeded, record current timestamp) (from '# 未超限，记录当前时间戳 (Not exceeded, record current timestamp)')
Comment: # (Not limited) (from '# 不限制 (Not limited)')
Comment: # endregion (appears multiple times)
Comment: # (Conceptual, unused dependency) (from '# 这是一个概念性的、未实际使用的依赖项 (Conceptual, unused dependency)')
Comment: # (Exporting these globals for potential external monitoring/management, but direct modification from other modules is generally not recommended)
Comment: # (This module provides rate limiting functionality and should not be executed directly.)
Comment: # (FastAPI Dependency - Conceptual) (from '# region FastAPI 依赖项 (用于路由中直接应用速率限制) - 概念性 (FastAPI Dependency - Conceptual)')
Comment: # (Note: The following dependency `rate_limit_dependency` ... intricate dependency chains.)
Comment: # (This action type would need to be passed somehow in the route definition)
Comment: # (Example: dependency to get user tags)
Comment: # (A generic rate-limiting FastAPI dependency (conceptual demonstration).)
Comment: # (In practice, specific dependencies might be needed for each limited action, or `is_rate_limited` is called within route functions (current approach).)
Comment: # (Example implementation logic): (from '# # 示例实现逻辑 (Example implementation logic):')
Comment: # (Use helper to get IP) (from '# client_ip = get_client_ip_from_request(request) # 使用项目中的工具函数获取IP (Use helper to get IP)')
Comment: # (Assume user_tags obtained via another dependency) (from '# # 假设 user_tags 已通过另一个依赖项获取 (Assume user_tags obtained via another dependency)')
Comment: # (Admins usually bypass rate limits) (from '# # 管理员通常不受速率限制 (Admins usually bypass rate limits)')
Comment: # (Rate limit exceeded for action: {action_type}. Please try again later.) (from detail string in commented out HTTPException)
Comment: # (Currently a no-op; actual limiting in route handlers) (from '# pass # 当前为空操作，实际限制在路由处理函数中完成 (Currently a no-op; actual limiting in route handlers)')

---
File: app/core/security.py
Comment: # (Security-related Utility Module) (Docstring)
Comment: # (This module provides core security functionalities such as password hashing and verification, access token generation and validation, and permission checks based on user tags. It uses passlib for password handling and implements a simple in-memory token storage mechanism.) (Docstring)
Comment: # (For asynchronous locks)
Comment: # (Standard logging module)
Comment: # (For generating secure random strings as tokens)
Comment: # (For handling token expiration times)
Comment: # (FastAPI 相关导入)
Comment: # (For password hashing)
Comment: # (UserTag enum from models)
Comment: # (Application global settings)
Comment: # (Logger instance for this module)
Comment: # (Password hashing context configuration)
Comment: # (Using bcrypt algorithm, one of the currently recommended strong hashing algorithms.)
Comment: # (`deprecated="auto"` will automatically upgrade to the new configuration when validating old format hashes (if schemes are changed in the future).)
Comment: # (In-memory active token storage)
Comment: # (Structure): {"token_string": {"user_uid": "uid", "tags": ["tag_value1"], "expires_at": timestamp}}
Comment: # (Note: This in-memory storage scheme is only suitable for single-process deployments.)
Comment: # (In multi-process or multi-instance environments (e.g., using Gunicorn multi-workers or Kubernetes), external shared storage (like Redis, Memcached, or a database) is needed to manage tokens to ensure all instances share the same token state.)
Comment: # (Async lock for concurrent control of operations on `_active_tokens` dictionary)
Comment: # (Verifies if the plaintext password matches the hashed password. `passlib` automatically extracts salt and algorithm information from `hashed_password` for comparison.) (Docstring for verify_password)
Comment: # (User-input plaintext password.)
Comment: # (The `passlib`-hashed password string stored in the database.)
Comment: # (True if passwords match, False otherwise.)
Comment: # (Generates a hash for the given plaintext password. When using the `bcrypt` algorithm, `passlib` automatically generates and manages a unique salt for each hash.) (Docstring for get_password_hash)
Comment: # (Plaintext password to be hashed.)
Comment: # (The hashed password string, which includes the algorithm, salt, and the hash itself.)
Comment: # (Generates a new access token for the specified user and stores it in the in-memory active token list. The token is a pseudo-random hexadecimal string generated using `secrets.token_hex`.) (Docstring for create_access_token)
Comment: # (User's unique identifier.)
Comment: # (List of tags the user possesses (UserTag enum members).)
Comment: # (The generated access token string.)
Comment: # (Ensure atomic operation on _active_tokens)
Comment: # (Get token length from config)
Comment: # (Generate secure hex token)
Comment: # (Token validity period)
Comment: # (Calculate expiration timestamp)
Comment: # (Store string values of tags)
Comment: # (Validates if the provided token is valid (exists in the active list and has not expired).) (Docstring for validate_token_and_get_user_info)
Comment: # (Access token provided by the client.)
Comment: # (If the token is valid, returns a dictionary containing "user_uid" (str) and "tags" (List[UserTag]). If the token is invalid or expired, returns None and internally cleans up the expired token.) (Return part of Docstring)
Comment: # (Safely convert stored tag string values back to UserTag enum members)
Comment: # (Ensure it's a valid enum value)
Comment: # (Remove problematic token)
Comment: # (Invalidates the specified token immediately (e.g., on user logout or token refresh). Removes the token from the in-memory active token list.) (Docstring for invalidate_token)
Comment: # (Token to be invalidated.)
Comment: # (Periodically cleans up all expired tokens from memory. This function should be called periodically by a background task.) (Docstring for cleanup_expired_tokens_periodically)
Comment: # (Create a copy for iteration)
Comment: # (Retrieves a list of information for all currently active tokens.) (Docstring for get_all_active_token_info)
Comment: # (Each dictionary contains token_prefix, user_uid, tags, and expires_at (ISO format string).)
Comment: # (Double check expiry, though cleanup should handle most, this function might be called between cleanups)
Comment: # (Token is expired, might as well remove it if found here, though cleanup is primary)
Comment: # (Avoid modifying during unprotected iteration if not list(_active_tokens.items()))
Comment: # (For safety, let cleanup_expired_tokens_periodically handle actual removal)
Comment: # (Tags are already stored as list of strings)
Comment: # (Invalidates all active tokens for a specified user immediately.) (Docstring for invalidate_all_tokens_for_user)
Comment: # (The UID of the user whose tokens need to be invalidated.)
Comment: # (The number of tokens that were successfully invalidated.)
Comment: # (First, identify tokens to remove to avoid modifying dict while iterating)
Comment: # (Now, remove the identified tokens)
Comment: # (Check if still exists (might be removed by another process/task if not careful))
Comment: # (FastAPI Dependency: Gets the token from query parameters, validates its effectiveness, and returns user information (including UID and tags). Throws corresponding HTTPException if the token is invalid, expired, or the user is banned.) (Docstring for get_current_user_info_from_token)
Comment: # (User access token passed via query parameter.)
Comment: # (Dictionary containing user UID (`user_uid`) and user tags (`tags`).)
Comment: # (If token is invalid or expired.)
Comment: # (If user account is banned.)
Comment: # (Fully Chinese)
Comment: # (提示客户端使用QueryToken方案)
Comment: # (检查用户是否被封禁)
Comment: # (Fully Chinese)
Comment: # (FastAPI Dependency: Extracts and returns the UID of the current active user from the user information returned by `get_current_user_info_from_token`. This dependency is typically used for routes that only require the user UID and not the full user information.) (Docstring for get_current_active_user_uid)
Comment: # (User information dictionary injected by the `get_current_user_info_from_token` dependency.)
Comment: # (UID of the current active user.)
Comment: # (Old HTTP Basic auth logic - to be removed if not used)
Comment: # (Internal helper function: Validates if HTTP Basic auth credentials match preset admin username/password.)
Comment: # (Admin HTTP Basic auth failed for username: '{credentials.username}')
Comment: # (Incorrect admin credentials)
Comment: # (Note: This basic auth doesn't directly return a user model or tags, only for access control.)
Comment: # (FastAPI Dependency: Ensures the current user is authenticated as admin via HTTP Basic.)
Comment: # (This function is mainly for dependency injection; actual username is validated in _authenticate_admin_user_http_basic.)
Comment: # (FastAPI dependency class used to check if the currently authenticated user possesses all specified required tags. This class can be instantiated and used to protect specific API endpoints, ensuring that only users with particular permissions (tags) can access them.) (Docstring for RequireTags)
Comment: # (Initializes the permission checker.) (Docstring for __init__ in RequireTags)
Comment: # (A set containing required `UserTag` enum members. The user must possess all tags in this set to pass the check.)
Comment: # (Permission checking logic executed when called as a FastAPI dependency. Throws an HTTP 403 (Forbidden) error if the user lacks any required tags.) (Docstring for __call__ in RequireTags)
Comment: # (User information injected by `get_current_user_info_from_token`.)
Comment: # (If permission check passes, returns the original `user_info` dictionary.)
Comment: # (If the user does not possess all required tags.)
Comment: # (检查用户是否拥有所有必需标签)
Comment: # (Insufficient permissions)
Comment: # (Predefined permission check dependency instances for direct use in routes)
Comment: # (Requires ADMIN tag)
Comment: # (Requires USER tag (typically all normal logged-in users have this))
Comment: # (Requires GRADER tag (grader))
Comment: # (Requires EXAMINER tag (question/paper admin))
Comment: # (Requires MANAGER tag (subset of admin, may have specific management perms))
Comment: # (New function) - Appears twice, likely for get_all_active_token_info and invalidate_all_tokens_for_user
Comment: # (Removed) (referring to get_current_admin_user)
Comment: # (Exposing pwd_context allows other parts to use hashing functions directly)
Comment: # (This module should not be executed as the main script. It defines security-related tools and should be imported and used by other modules.)

---
File: app/crud/__init__.py
Comment: # (Global instances will be set by the initialize_crud_instances function)
Comment: # (TODO: Add other entity types and their file paths as needed in the future)
Comment: # (应用设置的JSON文件名示例)
Comment: # (题库元数据文件名示例)
Comment: # (SettingsCRUD might not use the generic repository instance directly; it has its own config file handling logic)
Comment: # (Initialized instances (preferred for use in most app logic))
Comment: # (Initialization function)
Comment: # (CRUD Class definitions (for type hinting, internal use))
Comment: # (Note: This is the actual class name) (referring to QuestionBankCRUD)
Comment: # (Repository Class definitions (for type hinting, specific scenarios))

---
File: app/crud/json_repository.py
Comment: # (List of common ID field names for automatic indexing)
Comment: # (Initializes the JsonStorageRepository.) (Docstring for __init__)
Comment: # (A dictionary mapping entity types to their respective JSON file paths (relative to `base_data_dir`).)
Comment: # (The base directory for storing data files.)
Comment: # (In-memory ID index: {entity_type: {id_field_name: {entity_id_value: entity_object_reference}}})
Comment: # (Create an async lock for file operations for each predefined entity type)
Comment: # (Note: If new entity types are dynamically added via the `create` method, ensure locks are also created for these new types (handled in `create` method).)
Comment: # (Load all data and build indexes on initialization)
Comment: # (Builds in-memory ID indexes for the specified entity type.) (Docstring for _build_id_indexes)
Comment: # (This method iterates through the data of an entity type and creates an index for each ID field defined in `COMMON_ID_FIELDS`.)
Comment: # (The entity type for which to build indexes.)
Comment: # (Clear all existing ID field indexes for this entity type)
Comment: # (Ensure ID value is string)
Comment: # (If the index for this ID field hasn't been initialized, create it)
Comment: # (Add to index, value is a reference to the actual object in memory)
Comment: # (Build indexes for the loaded data)
Comment: # (Persists in-memory data of the specified entity type to its JSON file asynchronously.) (Docstring for _persist_data_to_file)
Comment: # (Performance Warning): This method rewrites the entire JSON file... consider more robust data storage solutions or optimized writing strategies.)
Comment: # (Retrieves a single entity from memory by ID, prioritizing ID indexes.) (Docstring for get_by_id)
Comment: # (Retrieves all entities of a specified type (in-memory copies), supports pagination. Performance note: This operation slices the in-memory list directly; deepcopy cost might be high for very large lists.) (Docstring for get_all)
Comment: # (Updates an existing entity in memory by ID and persists changes asynchronously. Assumes ID fields themselves are not modified. If ID fields are mutable, more complex index update logic (remove old index, add new index) would be required.) (Docstring for update)
Comment: # B007: Renamed i to _i (code style note, not for translation)
Comment: # (ID field '{id_field_name}' modification via update method is prohibited).
Comment: # Check if found in this scan pass
Comment: # If found via linear scan
Comment: # Now it's deleted from list
Comment: # (Queries entities from memory based on a set of conditions. Performance note: This query is a linear scan and may be slow for large datasets.) (Docstring for query)

---
File: app/crud/mysql_repository.py
Comment: # (MySQL/MariaDB Data Storage Repository Implementation Module.) (Docstring)
Comment: # (This module provides a concrete implementation of the `IDataStorageRepository` interface, using MySQL or MariaDB as the backend database. It utilizes the `aiomysql` library for asynchronous database operations.) (Docstring)
Comment: # (For serializing/deserializing JSON fields)
Comment: # (aiomysql might not have complete type stubs)
Comment: # (For specific MySQL error handling)
Comment: # (Import abstract base class)
Comment: # (Table name constants)
Comment: # (Users table)
Comment: # (Papers table)
Comment: # (Question bank metadata table)
Comment: # (Question bank contents table)
Comment: # (Note: QB_CONTENT_ENTITY_TYPE_PREFIX is used for dynamically identifying question bank content entity types. Its actual value should be consistent with the definition in qb_crud.py or passed via configuration.)
Comment: # (A data storage repository implementation using MySQL/MariaDB for persistence. This class implements all asynchronous methods defined in the IDataStorageRepository interface.) (Docstring for MySQLStorageRepository)
Comment: # (Initializes the MySQLStorageRepository.) (Docstring for __init__)
Comment: # (Database server hostname or IP address.)
Comment: # (Database server port.)
Comment: # (Username for database connection.)
Comment: # (Password for database connection.)
Comment: # (Name of the database to connect to.)
Comment: # ((Optional) asyncio event loop. Uses default loop if not provided.)
Comment: # (aiomysql connection pool instance)
Comment: # (MySQLStorageRepository initialized.)
Comment: # (Establishes a connection pool to the MySQL database.) (Docstring for connect)
Comment: # (MySQL connection pool already exists.)
Comment: # (Simplify transaction management, auto-commit each statement)
Comment: # (MySQL connection pool established successfully.)
Comment: # (Failed to establish MySQL connection pool)
Comment: # (Closes the MySQL connection pool.) (Docstring for disconnect)
Comment: # (Wait for all connections to close)
Comment: # (MySQL connection pool closed.)
Comment: # (No active MySQL connection pool to close.)
Comment: # (Ensures the database table for the specified entity type exists. Creates it if it doesn't.) (Docstring for init_storage_if_needed)
Comment: # ((The `default_data` parameter is typically not used directly in this MySQL implementation...))
Comment: # (Entity type for which storage needs to be initialized.)
Comment: # ((Unused) Default data for population.)
Comment: # (Connection pool not initialized, attempting to connect in init_storage_if_needed.)
Comment: # (Database connection pool must be available in init_storage_if_needed.)
Comment: # (MySQL's TEXT type is usually large enough; JSON type for JSON documents. CHAR(36) for UUIDs. DATETIME for timestamps.)
Comment: # (Users table structure)
Comment: # (Table '{USER_TABLE}' checked/created.)
Comment: # (Papers table structure)
Comment: # (Table '{PAPER_TABLE}' checked/created.)
Comment: # (Question bank metadata table structure)
Comment: # (Table '{QB_METADATA_TABLE}' checked/created.)
Comment: # (Question bank contents table structure)
Comment: # (Table '{QB_CONTENT_TABLE}' checked/created.)
Comment: # (Table structure definition not found for entity type '{entity_type}'.)
Comment: # (Helper method: Gets the corresponding table name and primary key column name based on entity type.) (Docstring for _get_table_info)
Comment: # (For tables with composite primary keys (e.g., question_bank_contents), returns the main ID column.)
Comment: # (Question bank content uses difficulty_id as the primary identifier, content_id as secondary)
Comment: # (Unknown entity type, cannot map to table name)
Comment: # (Unsupported entity type (MySQL))
Comment: # (Helper: Deserialize potential JSON string fields in a record.) (Docstring for _deserialize_json_fields)
Comment: # (Failed to deserialize field '{key}', value is not a JSON string: '{value[:50]}...')
Comment: # (Keep as original string or set to None/[] depending on business needs)
Comment: # (Helper: Serialize fields in entity data that need to be stored as JSON strings.) (Docstring for _serialize_json_fields)
Comment: # (Operate on a copy)
Comment: # (Retrieves a single entity by ID from the MySQL database.) (Docstring for get_by_id)
Comment: # (Special handling for question bank content entity type)
Comment: # (Assume entity_id for qb_content corresponds to difficulty_id, using default content_id)
Comment: # (Adapt return structure for qb_content)
Comment: # (Error)
Comment: # (Retrieves all entities of a specified type from MySQL, with pagination.) (Docstring for get_all)
Comment: # (Question bank content usually fetched by difficulty_id, not suitable for generic get_all unless specific need)
Comment: # (get_all not recommended for entity type '{entity_type}', use get_by_id (difficulty_id). Returning empty list.)
Comment: # (Error)
Comment: # (Creates a new entity in the MySQL database.) (Docstring for create)
Comment: # (Special handling for qb_content)
Comment: # (Ensure difficulty_id and content_id exist)
Comment: # (entity_data["id"] should map to difficulty_id)
Comment: # (Remove original id field, if present)
Comment: # (Default content_id)
Comment: # (Column names use backticks to avoid keyword conflicts)
Comment: # (Ensure one row was inserted)
Comment: # (For non-auto-increment PKs, MySQL lastrowid may not apply, return original data)
Comment: # (Return original entity_data (non-JSON-serialized) for interface consistency)
Comment: # (Create operation affected 0 rows.)
Comment: # (IntegrityError)
Comment: # (Entity creation failed due to integrity constraint (e.g., duplicate ID))
Comment: # (Error)
Comment: # (Updates an existing entity by ID in the MySQL database.) (Docstring for update)
Comment: # (If no update data is provided, return current entity)
Comment: # (Special handling for qb_content)
Comment: # (Get and return updated record)
Comment: # (Update operation affected 0 rows)
Comment: # (No matching record found or not updated)
Comment: # (Error)
Comment: # (Deletes an entity by ID from the MySQL database.) (Docstring for delete)
Comment: # (Special handling for qb_content)
Comment: # (rowcount indicates affected rows)
Comment: # (Error)
Comment: # (Queries entities from MySQL based on a set of conditions.) (Docstring for query)
Comment: # (For JSON field queries, direct comparison might be inaccurate, depending on MySQL version and JSON function usage.)
Comment: # (Simple handling here; advanced queries might need json_extract, etc.)
Comment: # (If query condition value is dict or list, try serializing to JSON string for comparison)
Comment: # (If no conditions, select all)
Comment: # (Special handling for qb_content return structure)
Comment: # (Error)
Comment: # (Returns a list of all entity types known or expected to be managed by this repository (based on defined table constants).) (Docstring for get_all_entity_types)
Comment: # (For MySQL, data is written live, so this method is a no-op.) (Docstring for persist_all_data)
Comment: # (Called (no-op, data is persisted live).)
Comment: # (Export MySQL repository class)
Comment: # (This module should not be executed as the main script. It defines the MySQL data storage repository implementation.)
Comment: # (This module defines the MySQL repository and should not be executed directly.)

---
File: app/crud/paper.py
Comment: # (Paper Data Management Module) (Docstring)
Comment: # (This module defines the `PaperCRUD` class for handling all Create, Read, Update, and Delete (CRUD) operations related to exam papers...) (Docstring)
Comment: # (Added for asyncio.create_task)
Comment: # (App config and constants)
Comment: # (Data storage repository interface)
Comment: # (Paper-related Pydantic models)
Comment: # (Utility functions)
Comment: # (PaperCRUD - Create, Read, Update, Delete). Interacts with the underlying data storage via IDataStorageRepository. Relies on QuestionBankCRUD to fetch question bank content. (Docstring for PaperCRUD)
Comment: # (Expected: instance of QuestionBankCRUD)
Comment: # (Pass internal_question_id to client)
Comment: # (For choice questions)
Comment: # (For subjective questions, keyed by internal_question_id)
Comment: # (Note: This method currently only saves objective answers via submitted_answers...)
Comment: # (Only process for choice questions here)
Comment: # (For subjective questions, student_subjective_answer is updated elsewhere (e.g. during grading or a dedicated save))
Comment: # (Save processed answers for all questions)
Comment: # (Persist changes)
Comment: # (Contains answers for objective questions)
Comment: # (And text for subjective questions, keyed by internal_question_id)
Comment: # (Should not happen if previous update succeeded)
Comment: # (Represents objective score at this stage)
Comment: # (Persist updated subjective answers)
Comment: # (Add passcode to update_fields)
Comment: # (This is objective score or final total if finalized)
Comment: # (Show total_score if available)
Comment: # (Will be populated based on type)
Comment: # (For consistency if client uses submitted_answer)
Comment: # (For single_choice etc.)
Comment: # (Prepare final response dict)
Comment: # (This is current objective score)
Comment: # (Assume each question (objective or subjective) contributes to total_possible_points...)
Comment: # (This part might need refinement based on how max scores for subjective Qs are defined.)
Comment: # (If each question is 1 point, total_possible_points = len(paper_questions)...)
Comment: # (For now, let's assume each question is 1 point for simplicity of pass/fail.)
Comment: # (Store the combined score explicitly)
Comment: # (To be set below)
Comment: # (This query needs to be supported by the repository or done in multiple steps/filtered here.)
Comment: # (Assuming repository query can handle "field > value" or we fetch and filter.)
Comment: # (For simplicity with current IDataStorageRepository, we might fetch PENDING_REVIEW and then filter.)
Comment: # (Limit might need to be higher if filtering significantly reduces results)
Comment: # (Or implement proper DB-level filtering for pending_manual_grading_count > 0)
Comment: # (Fetch more to allow filtering, adjust as needed)
Comment: # (Initial skip is 0, pagination handled after filtering)
Comment: # (Manual pagination on the filtered list)
Comment: # (Trigger finalization check (can run in background, or be awaited by API layer if needed))

---
File: app/crud/postgres_repository.py
Comment: # (PostgreSQL Data Storage Repository Implementation Module.) (Docstring)
Comment: # (This module provides a concrete implementation of the `IDataStorageRepository` interface, using PostgreSQL as the backend database. It utilizes the `asyncpg` library for asynchronous database operations.) (Docstring)
Comment: # (For handling UUID type)
Comment: # (asyncpg 默认可能没有类型存根 / asyncpg might not have stubs by default)
Comment: # (Import abstract base class)
Comment: # (QB_CONTENT_ENTITY_TYPE_PREFIX is used for dynamically identifying question bank content entity types. Its actual value should be consistent with the definition in qb_crud.py or passed via configuration.)
Comment: # (A data storage repository implementation using PostgreSQL for persistence. This class implements all asynchronous methods defined in the IDataStorageRepository interface and interacts with a PostgreSQL database.) (Docstring for PostgresStorageRepository)
Comment: # (Initializes the PostgresStorageRepository. Connection can be configured via a DSN string or individual connection parameters (host, user, database, etc.).) (Docstring for __init__)
Comment: # (PostgreSQL DSN. If provided, it takes precedence.)
Comment: # (If neither DSN nor sufficient individual connection parameters are provided.)
Comment: # (If not using DSN, filter out None parameters)
Comment: # (asyncpg connection pool instance)
Comment: # (PostgresStorageRepository initialized.)
Comment: # (Establishes a connection pool to the PostgreSQL database. If the pool already exists, this is a no-op. If connection fails, logs an error and may raise an exception.) (Docstring for connect)
Comment: # (PostgreSQL connection pool already exists.)
Comment: # (Configure pool size)
Comment: # (PostgreSQL connection pool established successfully.)
Comment: # (Failed to establish PostgreSQL connection pool)
Comment: # (Closes the PostgreSQL connection pool.) (Docstring for disconnect)
Comment: # (PostgreSQL connection pool closed.)
Comment: # (No active PostgreSQL connection pool to close.)
Comment: # (Ensures the database table for the specified entity type exists. Creates it if it doesn't. The `default_data` parameter is typically not used directly in this PostgreSQL implementation.) (Docstring for init_storage_if_needed)
Comment: # (Entity type for which storage needs to be initialized.)
Comment: # ((Unused) Default data for population.)
Comment: # (Connection pool not initialized, attempting to connect in init_storage_if_needed.)
Comment: # (DB pool must be available.)
Comment: # (Acquire a connection from the pool)
Comment: # (Define and create table structure based on entity type)
Comment: # (Table 'users' checked/created.)
Comment: # (Table 'papers' checked/created.)
Comment: # (Table 'question_bank_metadata' checked/created.)
Comment: # (Table 'question_bank_contents' checked/created.)
Comment: # (Table structure definition for entity type '{entity_type}' not found.)
Comment: # (Helper method: Gets the corresponding table name and primary key column name based on entity type.) (Docstring for _get_table_info)
Comment: # ('difficulty_id' is part of composite PK)
Comment: # (Unknown entity type, cannot map to table name)
Comment: # (Unsupported entity type)
Comment: # (Retrieves a single entity by ID from PostgreSQL.) (Docstring for get_by_id)
Comment: # (Assume content_id is 'default')
Comment: # (Paper ID is UUID)
Comment: # (Invalid UUID format for paper_id)
Comment: # (Return qb_content specific structure)
Comment: # (Table '{table_name}' does not exist (get_by_id). Attempting to initialize...)
Comment: # (Initialize后，当前查询仍返回None)
Comment: # (Error)
Comment: # (Retrieves all entities of a specified type from PostgreSQL, with pagination.) (Docstring for get_all)
Comment: # (Table '{table_name}' does not exist (get_all). Attempting to initialize...)
Comment: # (Initialize后，当前查询返回空列表)
Comment: # (Error)
Comment: # (Creates a new entity in PostgreSQL.) (Docstring for create)
Comment: # ('id' in entity_data is difficulty_id)
Comment: # (Remove original 'id' key as it's now difficulty_id)
Comment: # (Default content_id)
Comment: # (Convert to UUID type)
Comment: # (Invalid UUID for paper_id (on create))
Comment: # (Insert operation did not return a new record.)
Comment: # (Return qb_content specific structure)
Comment: # (UniqueViolationError)
Comment: # (Unknown ID)
Comment: # (Entity with this ID already exists in type '{entity_type}'.)
Comment: # (Table '{table_name}' does not exist (create). Attempting to initialize...)
Comment: # (Retry insert)
Comment: # (Insert failed after table creation attempt.)
Comment: # (Error)
Comment: # (Updates an existing entity by ID in PostgreSQL.) (Docstring for update)
Comment: # (Invalid paper_id format in update)
Comment: # (Invalid entity_id (paper_id) format in update)
Comment: # (Table '{table_name}' does not exist (update). Attempting to initialize...)
Comment: # (Error)
Comment: # (Deletes an entity by ID from PostgreSQL.) (Docstring for delete)
Comment: # (Invalid entity_id (paper_id) format in delete)
Comment: # (Table '{table_name}' does not exist (delete). Attempting to initialize...)
Comment: # (Error)
Comment: # (Queries entities from PostgreSQL based on a set of conditions.) (Docstring for query)
Comment: # (PostgreSQL uses $1, $2... as placeholders)
Comment: # (Return qb_content specific structure)
Comment: # (Table '{table_name}' does not exist (query). Attempting to initialize...)
Comment: # (Error)
Comment: # (Returns a list of all entity types known/expected to be managed.) (Docstring for get_all_entity_types)
Comment: # (get_all_entity_types not fully dynamic for PostgreSQL, returns known types.)
Comment: # (For PostgreSQL, data is persisted live; this is a no-op.) (Docstring for persist_all_data)
Comment: # (Called (no-op, data is persisted live).)
Comment: # (Export PostgreSQL repository class)
Comment: # (This module should not be executed as the main script. It defines the PostgreSQL data storage repository implementation.)
Comment: # (This module defines the PostgreSQL repository and should not be executed directly.)

---
File: app/crud/qb.py
Comment: # (Question Bank Data Management Module) (Docstring)
Comment: # (This module defines the `QuestionBankCRUD` class for handling all Create, Read, Update, and Delete (CRUD) operations related to question banks...) (Docstring)
Comment: # (Import global config and DifficultyLevel enum)
Comment: # (Data storage repository interface)
Comment: # (QB-related Pydantic models)
Comment: # (QuestionBankCRUD). Interacts with the underlying data storage via IDataStorageRepository. (Docstring for QuestionBankCRUD)
Comment: # (Initializes QuestionBankCRUD.) (Docstring for __init__)
Comment: # (Instance of a repository implementing IDataStorageRepository.)
Comment: # (QuestionBankCRUD initialized with injected repository.)
Comment: # (Ensures that the storage for question bank metadata and content is initialized if needed. Should be called once during application startup.) (Docstring for initialize_storage)
Comment: # (Initialize metadata storage)
Comment: # (Storage for entity type '{QB_METADATA_ENTITY_TYPE}' initialized if needed.)
Comment: # (Initialization for question bank content files can be added here if needed, or they can be dynamically created upon first access.)
Comment: # (For example, if all difficulty levels are known, content entities can be pre-created:)
Comment: # (Storage for all known difficulty QB contents checked/created.)
Comment: # (Reads all question bank metadata items from the repository.) (Docstring for _read_library_index_internal)
Comment: # (Assuming max 1000 difficulties)
Comment: # (Gets the list of all question bank metadata (read from repository and validated).) (Docstring for get_all_library_metadatas)
Comment: # (Fetching all question bank metadata...)
Comment: # (UsePydantic模型进行验证和转换)
Comment: # (Pydantic ValidationError)
Comment: # (Invalid metadata item found in library index)
Comment: # (Error)
Comment: # (Successfully loaded {len(valid_metadatas)} valid QB metadata items.)
Comment: # (Gets metadata for a single question bank by difficulty ID (string).) (Docstring for get_library_metadata_by_id)
Comment: # (Fetch directly from repository instead of getting all then filtering)
Comment: # (Invalid metadata for QB (ID: {difficulty_id}))
Comment: # (Error)
Comment: # (Reads question bank content (list of questions) for a specific difficulty from the repository.) (Docstring for _read_question_bank_file_content_internal)
Comment: # (QB content entity ID convention is difficulty_id)
Comment: # (No content found or content format error for question bank '{difficulty_id}'.)
Comment: # (Writes question bank content (list of questions) for a specific difficulty to the repository.) (Docstring for _write_question_bank_file_content_internal)
Comment: # (Entire list of questions stored as a field in a single document)
Comment: # (Document ID convention is difficulty_id)
Comment: # (Ensure document itself has 'id' field)
Comment: # (If exists, update)
Comment: # (Otherwise, create new document)
Comment: # (Gets the complete question bank for a specified difficulty (metadata + content), validated with Pydantic models.) (Docstring for get_question_bank_with_content)
Comment: # (Fetching full question bank for difficulty '{difficulty.value}'...)
Comment: # (Metadata not found for difficulty '{difficulty.value}'.)
Comment: # (Question data validation failed for index {q_idx} in bank '{difficulty.value}')
Comment: # (Error)
Comment: # (Validate total_questions in metadata against actual loaded count)
Comment: # (total_questions ({meta.total_questions}) in metadata for bank '{meta.id}' does not match actual loaded valid questions count ({len(questions_models)}). Metadata will be updated with actual loaded count.)
Comment: # (Update metadata in repository)
Comment: # (Adds a new question to the question bank of specified difficulty and updates total_questions in metadata.) (Docstring for add_question_to_bank)
Comment: # (Adding new question to bank '{difficulty_id}'...)
Comment: # (Add new question data)
Comment: # (Get metadata to update total count)
Comment: # (Metadata for bank '{difficulty_id}' updated, new total questions: {meta.total_questions}.)
Comment: # (If metadata doesn't exist, this shouldn't normally happen unless index file is corrupt or not properly initialized)
Comment: # (Metadata for bank '{difficulty_id}' not found, cannot update total questions!)
Comment: # (Question successfully added to bank '{difficulty_id}'.)
Comment: # (Failed to add question to bank '{difficulty_id}' (write to storage failed).)
Comment: # (Deletes a question by index from the question bank of specified difficulty and updates total_questions in metadata.) (Docstring for delete_question_from_bank)
Comment: # (Deleting question at index {question_index} from bank '{difficulty_id}'...)
Comment: # (Check index validity)
Comment: # (Attempted to delete invalid index {question_index} from bank '{difficulty_id}'.)
Comment: # (Remove question)
Comment: # (Update metadata)
Comment: # (Metadata for bank '{difficulty_id}' updated, new total questions: {meta.total_questions}.)
Comment: # (Metadata for bank '{difficulty_id}' not found, cannot update total questions!)
Comment: # (Successfully deleted question at index {question_index} from bank '{difficulty_id}'.)
Comment: # (Return deleted question data)
Comment: # (Failed to delete question from bank '{difficulty_id}' (write to storage failed).)
Comment: # (Export QuestionBankCRUD class)
Comment: # (Export metadata entity type constant)
Comment: # (Export content entity type prefix constant)
Comment: # (This module should not be executed as the main script. It defines the CRUD operations class for question bank data.)
Comment: # (This module provides CRUD operations class for question bank data and should not be executed directly.)

---
File: app/crud/redis_repository.py
Comment: # (Redis Data Storage Repository Implementation Module.) (Docstring)
Comment: # (This module provides a concrete implementation of the `IDataStorageRepository` interface, using Redis as the backend data store...) (Docstring)
Comment: # (For JSON serialization and deserialization)
Comment: # (aioredis might not have complete type stubs)
Comment: # (Import abstract base class)
Comment: # (For key name construction)
Comment: # (Redis key prefix or pattern definitions)
Comment: # (User entity key prefix)
Comment: # (Paper entity key prefix)
Comment: # (Question bank metadata key prefix)
Comment: # (Key prefix for sets storing entity IDs)
Comment: # (A data storage repository implementation using Redis for persistence. Entities are stored as JSON strings...) (Docstring for RedisStorageRepository)
Comment: # (Initializes the RedisStorageRepository.) (Docstring for __init__)
Comment: # (e.g.): "redis://localhost:6379/0"
Comment: # (Redis server hostname)
Comment: # (Redis server port)
Comment: # (Redis database number)
Comment: # (Redis connection password (optional))
Comment: # (Redis connection URL. If provided, this URL is used preferentially.)
Comment: # (Construct connection URL from individual parameters)
Comment: # (aioredis connection instance)
Comment: # (RedisStorageRepository initialized.)
Comment: # (Generates a Redis key name based on entity type and ID.) (Docstring for _get_entity_key)
Comment: # (e.g.): "user:user123", "paper:paper_abc", "qb_content_easy:easy"
Comment: # (For entity types with specific prefixes like question bank content, key construction might differ)
Comment: # (entity_id for qb_content is already difficulty_id)
Comment: # (e.g. "qb_content_easy:easy")
Comment: # (General format)
Comment: # (Generates the Redis Set key name for storing all IDs of a given entity type.) (Docstring for _get_entity_ids_set_key)
Comment: # (e.g.): "entity_ids:user", "entity_ids:paper", "entity_ids:qb_content_easy"
Comment: # (Establishes a connection to the Redis server.) (Docstring for connect)
Comment: # (aioredis v2+)
Comment: # (Redis connection already established.)
Comment: # (Test connection)
Comment: # (Redis connection established successfully.)
Comment: # (Failed to establish Redis connection)
Comment: # (Closes the connection to the Redis server.) (Docstring for disconnect)
Comment: # (Redis connection closed.)
Comment: # (No active Redis connection to close.)
Comment: # (Ensures storage for the given entity type is initialized. For Redis, this is mainly a no-op.) (Docstring for init_storage_if_needed)
Comment: # (Called (entity type: '{entity_type}'), this is a no-op.)
Comment: # (Retrieves a single entity by ID from Redis (stored as JSON string).) (Docstring for get_by_id)
Comment: # (Redis connection not initialized)
Comment: # (Deserialize JSON string to dict)
Comment: # (Failed to decode JSON for key {key_name}.)
Comment: # (Key not found)
Comment: # (Retrieves all entities of a specified type from Redis. Implemented by fetching the ID set, then batch-fetching entity data...) (Docstring for get_all)
Comment: # (Get all IDs)
Comment: # (Try sorting for consistent pagination)
Comment: # (Cannot sort IDs for entity type '{entity_type}', pagination may be inconsistent.)
Comment: # (Paginate on Python side)
Comment: # (Batch get)
Comment: # (Failed to decode JSON for key {keys_to_fetch[i]}.)
Comment: # (Data for key {keys_to_fetch[i]} missing in mget operation.)
Comment: # (Creates a new entity in Redis (stored as JSON string).) (Docstring for create)
Comment: # (Determine primary key ID from entity_data)
Comment: # (For question bank content, entity_id is determined by the part after entity_type prefix)
Comment: # (Ensure 'id' field in data matches inferred ID)
Comment: # (Other general entity types)
Comment: # (Entity data must contain a recognizable ID field (id, uid, paper_id).)
Comment: # (Ensure primary key field in entity_data matches entity_id)
Comment: # (Optional: check if entity already exists)
Comment: # (Entity key {key_name} already exists. It will be overwritten.)
Comment: # (Use Pipeline for atomicity)
Comment: # (Add ID to set)
Comment: # (Updates an existing entity by ID in Redis.) (Docstring for update)
Comment: # (Entity does not exist)
Comment: # (Failed to decode existing JSON for key {key_name} (in update).)
Comment: # (Merge updates)
Comment: # (SET overwrites old value)
Comment: # (Deletes an entity by ID from Redis and its reference in the ID set.) (Docstring for delete)
Comment: # (Remove ID from set)
Comment: # (DEL returns number of keys successfully deleted)
Comment: # (Queries entities in Redis based on conditions. Simple implementation: gets all entities, then filters on the Python side. Warning: Extremely inefficient for large datasets.) (Docstring for query)
Comment: # (Performing inefficient query on Redis (get all then filter). Please optimize for large datasets.)
Comment: # (Cannot sort IDs for entity type '{entity_type}' (in query), results may be inconsistent.)
Comment: # (Fetch in batches to avoid overly long MGET or large responses)
Comment: # (This is a simple optimization; more complex scenarios might need smarter batching)
Comment: # (Configurable batch size)
Comment: # (Failed to decode JSON for key {keys_to_fetch[idx]} (in query).)
Comment: # (Data for key {keys_to_fetch[idx]} missing in MGET query.)
Comment: # (Apply filter conditions on Python side)
Comment: # (Exact match)
Comment: # (Apply pagination to filtered results)
Comment: # (Attempts to dynamically discover all entity types by scanning keys matching `entity_ids:*` pattern.) (Docstring for get_all_entity_types)
Comment: # (aioredis scan cursor starts as bytes)
Comment: # (Loop until cursor becomes 0 (or None for some clients))
Comment: # (Keys are already decoded if decode_responses=True for Redis client)
Comment: # (Extract part after "entity_ids:")
Comment: # (End of scan)
Comment: # (get_all_entity_types: No entity ID sets found. Returning predefined list or empty list.)
Comment: # (Provide some default types)
Comment: # (For Redis, data is persisted live (depending on Redis config); this is a no-op.) (Docstring for persist_all_data)
Comment: # (Called (no-op, Redis persists live).)
Comment: # (Export Redis repository class)
Comment: # (This module should not be executed as the main script. It defines the Redis data storage repository implementation.)
Comment: # (This module defines the Redis repository and should not be executed directly.)

---
File: app/crud/settings.py
Comment: # (Application Configuration Management Module) (Docstring)
Comment: # (This module defines the `SettingsCRUD` class, which is used to manage the reading and updating operations for the application's configuration (typically `settings.json`)...) (Docstring)
Comment: # (Module Imports)
Comment: # (For handling file paths)
Comment: # (Using relative import to import configuration management functions from the sibling core package)
Comment: # (Settings Pydantic model)
Comment: # (Global settings instance)
Comment: # (Function to update and persist settings)
Comment: # (Global Variables & Initialization)
Comment: # (Logger instance for this module)
Comment: # (Settings CRUD Class)
Comment: # (Manages read and update operations for the application configuration (`settings.json`). This class serves as an interface for managing `settings.json` via an API...) (Docstring for SettingsCRUD)
Comment: # (Initializes SettingsCRUD. The actual loading and management of configurations are handled by the global `settings` object in `app.core.config`...) (Docstring for __init__)
Comment: # (SettingsCRUD initialized, config file path)
Comment: # (Directly reads the current raw configuration content from the `settings.json` file. This method is primarily used for the Admin interface to display what the user has actually saved in the file...) (Docstring for get_current_settings_from_file)
Comment: # (A dictionary loaded from `settings.json`. Returns an empty dictionary if the file does not exist or is invalid, and logs an error.) (Return part of Docstring)
Comment: # (Attempting to read raw config from '{self.settings_file_path}'.)
Comment: # (Failed to read config from '{self.settings_file_path}')
Comment: # (Config file '{self.settings_file_path}' not found, returning empty config.)
Comment: # (Gets the currently active global configuration object in memory, which has been overridden by `.env` and validated by Pydantic. This is the configuration currently in use by the application.) (Docstring for get_active_settings)
Comment: # (The global `Settings` Pydantic model instance.) (Return part of Docstring)
Comment: # (Fetching active global settings instance.)
Comment: # (Directly return the loaded global settings object)
Comment: # (Asynchronously updates configuration items in the `settings.json` file and triggers a reload of the global configuration. This method calls the `update_and_persist_settings` function from `app.core.config`...) (Docstring for update_settings_file_and_reload)
Comment: # (A dictionary containing configuration items to update. e.g.: `{"token_expiry_hours": 48, "app_name": "新考试系统"}` Note: Keys in this dictionary should match field names in the `Settings` Pydantic model.)
Comment: # (The updated and reloaded global `Settings` Pydantic model instance.)
Comment: # (If the provided configuration data is invalid (e.g., does not meet Pydantic model constraints).)
Comment: # (If writing to the `settings.json` file fails.)
Comment: # (If other unknown errors occur during the update process.)
Comment: # (Attempting to update app config via CRUD)
Comment: # (App config successfully updated and reloaded via CRUD.)
Comment: # (Data validation failed during CRUD update)
Comment: # (IOError during CRUD update of config file)
Comment: # (Unknown error during CRUD update of config)
Comment: # (Export SettingsCRUD class)
Comment: # (This module should not be executed as the main script. It defines the CRUD operations class for application settings.)
Comment: # (This module provides CRUD operations class for application settings and should not be executed directly.)

---
File: app/crud/sqlite_repository.py
Comment: # (SQLite Data Storage Repository Implementation Module.) (Docstring)
Comment: # (This module provides a concrete implementation of the `IDataStorageRepository` interface, using SQLite as the backend database...) (Docstring)
Comment: # (For JSON serialization and deserialization)
Comment: # (For specific SQLite error types)
Comment: # (aiosqlite might not have complete type stubs)
Comment: # (Import abstract base class)
Comment: # (QB_CONTENT_ENTITY_TYPE_PREFIX for dynamically identifying QB content entity types)
Comment: # (Table name constants)
Comment: # (Users table)
Comment: # (Papers table)
Comment: # (Question bank metadata table)
Comment: # (Question bank contents table)
Comment: # (A data storage repository implementation using SQLite for persistence. This class implements all asynchronous methods defined in the IDataStorageRepository interface.) (Docstring for SQLiteStorageRepository)
Comment: # (Initializes the SQLiteStorageRepository.) (Docstring for __init__)
Comment: # (Path to the SQLite database file.)
Comment: # (SQLiteStorageRepository initialized with DB path)
Comment: # (Ensures the directory for the database file exists. For `aiosqlite`, connections are typically on-demand.) (Docstring for connect)
Comment: # (Ensure directory exists)
Comment: # (DB directory ensured)
Comment: # (Error ensuring DB directory for SQLite)
Comment: # (Closes the connection. For `aiosqlite`, this is typically a no-op.) (Docstring for disconnect)
Comment: # (Called (no-op)).
Comment: # (Ensures the table for the specified entity type exists. Creates it if not.) (Docstring for init_storage_if_needed)
Comment: # (The `default_data` parameter is not used in this implementation.)
Comment: # (Table '{USER_TABLE}' checked/created.)
Comment: # (Table '{PAPER_TABLE}' checked/created.)
Comment: # (Table '{QB_METADATA_TABLE}' checked/created.)
Comment: # (Table '{QB_CONTENT_TABLE}' checked/created.)
Comment: # (Table definition for entity type '{entity_type}' not found.)
Comment: # (Helper method: Gets table name and primary key column based on entity type.) (Docstring for _get_table_info)
Comment: # (PK is composite)
Comment: # (Unknown entity type, cannot map to table name)
Comment: # (Unsupported entity type (SQLite))
Comment: # (Helper: Deserialize potential JSON string fields in a record.) (Docstring for _deserialize_json_fields)
Comment: # (Failed to deserialize field '{key}', not JSON string: '{value[:50]}...')
Comment: # (Helper: Serialize fields in entity data to be stored as JSON strings.) (Docstring for _serialize_json_fields)
Comment: # (Retrieves a single entity by ID from SQLite.) (Docstring for get_by_id)
Comment: # (DB file path not set.)
Comment: # (Assume content_id is 'default')
Comment: # (Return qb_content specific structure)
Comment: # (Error)
Comment: # (Retrieves all entities of a type from SQLite, with pagination.) (Docstring for get_all)
Comment: # (DB file path not set.)
Comment: # (get_all not recommended for entity type '{entity_type}'. Returning empty list.)
Comment: # (Error)
Comment: # (Creates a new entity in SQLite.) (Docstring for create)
Comment: # (DB file path not set.)
Comment: # (Handle composite key and data structure for qb_content)
Comment: # (Remove original 'id')
Comment: # (SQLite backticks are optional, kept for consistency)
Comment: # (Return original data as confirmation)
Comment: # (IntegrityError)
Comment: # (Entity creation failed due to integrity constraint (e.g., duplicate ID))
Comment: # (Error)
Comment: # (Updates an existing entity by ID in SQLite.) (Docstring for update)
Comment: # (DB file path not set.)
Comment: # (Error)
Comment: # (Deletes an entity by ID from SQLite.) (Docstring for delete)
Comment: # (DB file path not set.)
Comment: # (Error)
Comment: # (Queries entities from SQLite based on a set of conditions.) (Docstring for query)
Comment: # (DB file path not set.)
Comment: # (Return qb_content specific structure)
Comment: # (Error)
Comment: # (Returns a list of all entity types known/expected to be managed (based on defined table constants).) (Docstring for get_all_entity_types)
Comment: # (For SQLite, data is persisted live (via commit); this is a no-op.) (Docstring for persist_all_data)
Comment: # (Called (no-op, data is persisted live).)
Comment: # (Export SQLite repository class)
Comment: # (This module should not be executed as the main script. It defines the SQLite data storage repository implementation.)
Comment: # (This module defines the SQLite repository and should not be executed directly.)

---
File: app/crud/user.py
Comment: # (User Data CRUD (Create, Read, Update, Delete) Operations Module.) (Docstring)
Comment: # (This module defines the `UserCRUD` class, which encapsulates the persistence operations logic related to user data...) (Docstring)
Comment: # (Module Imports)
Comment: # (For generating random password for initial admin)
Comment: # (Ensure Enum is imported)
Comment: # (Import global settings instance)
Comment: # (Import data storage repository interface)
Comment: # (Import password hashing utility)
Comment: # (User-related Pydantic models)
Comment: # (Global Variables & Initialization)
Comment: # (Logger instance for this module)
Comment: # (Entity type string for this CRUD operation)
Comment: # (UserCRUD Class)
Comment: # (User Data Management Class (UserCRUD). This class encapsulates all create, read, update, and delete operations related to user accounts...) (Docstring for UserCRUD)
Comment: # (Initializes UserCRUD.) (Docstring for __init__)
Comment: # (An instance of a repository implementing the `IDataStorageRepository` interface, which will be used for all user data persistence operations.)
Comment: # (UserCRUD initialized with injected repository.)
Comment: # (Initializes storage for user entities. If needed, this creates the corresponding table or ensures the file/collection exists...) (Docstring for initialize_storage)
Comment: # (Storage for entity type '{USER_ENTITY_TYPE}' initialized if needed.)
Comment: # (Checks if any users exist; if the database is empty, creates a default admin user. Password is preferentially read from config, otherwise a random password is generated and logged.) (Docstring for _initialize_admin_user_if_needed)
Comment: # (Checking if admin user initialization is needed...)
Comment: # (Admin user '{admin_uid}' already exists. Skipping creation.)
Comment: # (Initial admin password not specified in config. Generated random password for user '{admin_uid}': '{initial_password}'. Please record and change this password!)
Comment: # (Using initial password from config for user '{admin_uid}'.)
Comment: # (Initial admin account '{admin_uid}' auto-created and persisted.)
Comment: # (Users already exist in DB, skipping admin initialization.)
Comment: # (Retrieves user data from the repository by User ID (UID).) (Docstring for get_user_by_uid)
Comment: # (UserInDB model instance or `None`.)
Comment: # (Fetching user by UID '{uid}'...)
Comment: # (Model validation failed for user '{uid}')
Comment: # (Creates a new user. Fails if UID exists. Persists on success.) (Docstring for create_user)
Comment: # (UserInDB model instance or `None`.)
Comment: # (Attempting to create user UID: {user_create_data.uid})
Comment: # (Attempted to create existing user UID: {user_create_data.uid})
Comment: # (Ensure primary key 'uid' exists)
Comment: # (Data model validation failed for user '{user_create_data.uid}')
Comment: # (New user '{created_user_dict.get('uid')}' created successfully.)
Comment: # (Updates a specified user's profile (e.g., nickname, email, QQ number).) (Docstring for update_user_profile)
Comment: # (Updated UserInDB model instance or `None`.)
Comment: # (Profile update request for user '{user_uid}' contained no effective changes.)
Comment: # (Updating profile for user '{user_uid}'...)
Comment: # (Profile for user '{user_uid}' updated successfully.)
Comment: # (Failed to update profile for user '{user_uid}'.)
Comment: # (Updates a specified user's password. The provided password should be the new, already hashed password.) (Docstring for update_user_password)
Comment: # (`True` if successful, `False` otherwise.)
Comment: # (Updating password for user '{user_uid}'...)
Comment: # (Password for user '{user_uid}' updated successfully.)
Comment: # (Failed to update password for user '{user_uid}'.)
Comment: # (Admin Operations)
Comment: # (Admin Interface: Gets a list of all users (supports pagination).) (Docstring for admin_get_all_users)
Comment: # (List of UserInDB model instances.)
Comment: # (Admin requesting user list, skip={skip}, limit={limit}.)
Comment: # (User data '{user_data.get('uid')}' validation failed for admin)
Comment: # (Admin Interface: Updates specified user information, including profile, tags, and optional password reset.) (Docstring for admin_update_user)
Comment: # (Updated UserInDB model instance or `None`.)
Comment: # (Attempting to update info for user '{user_uid}'...)
Comment: # (If new password is provided)
Comment: # (Remove plaintext password field)
Comment: # (Handle tags)
Comment: # (Update request for user '{user_uid}' by admin contained no effective changes.)
Comment: # (Info for user '{user_uid}' updated successfully by admin.)
Comment: # (Failed to update user '{user_uid}' by admin.)
Comment: # (Cleans up all expired user access tokens from memory (or configured token storage). This method should be called periodically by a background task.) (Docstring for cleanup_expired_tokens)
Comment: # (Note: Current token management is in app.core.security, an in-memory solution...)
Comment: # (UserCRUD.cleanup_expired_tokens called, but current token cleanup is handled by app.core.security.)
Comment: # (Call security module's cleanup function (if UserCRUD needs to actively trigger))
Comment: # (Export UserCRUD class)
Comment: # (Export user entity type constant)
Comment: # (This module should not be executed as the main script. It defines the CRUD operations class for user data.)
Comment: # (This module provides CRUD operations class for user data and should not be executed directly.)

---
File: app/main.py
Comment: # (This is the main entry point file for the FastAPI application...) (Docstring)
Comment: # (For export filename timestamp)
Comment: # (Audit logger)
Comment: # (WebSocket Manager)
Comment: # (Export utilities)
Comment: # (tasks for startup and shutdown)
Comment: # (Cloudflare IP 更新任务 (当前注释掉))
Comment: # (延迟导入)
Comment: # (使用与旧DB持久化任务相同的间隔时间，可按需调整)
Comment: # (Cloudflare IP更新任务启动点)
Comment: # (包括数据库连接和表结构检查/创建)
Comment: # (对于JSON或文件型存储, 此方法会将内存数据写入文件。)
Comment: # (对于SQL数据库, 数据通常实时写入, 此方法可能为空操作或执行最终同步。)
Comment: # (可选)
Comment: # (如 cookies)
Comment: # (Audit log for rate limit)
Comment: # (Audit log for registration failure (user exists))
Comment: # (Audit log for successful registration)
Comment: # (返回Token)
Comment: # (从请求参数中获取Token)
Comment: # (创建新Token)
Comment: # (理论上不应发生，因为Token验证时用户应该存在于数据库中)
Comment: # (从数据库模型 (UserInDB) 转换为公开的模型 (UserPublicProfile))
Comment: # (确保detail为中文)
Comment: # (添加model到成功响应)
Comment: # (This returns List[Dict])
Comment: # (Default if no pass_status or status is not 'completed')
Comment: # (Assuming 'status' field indicates completion)
Comment: # (Assuming status is an enum or string)
Comment: # (Return empty file for export)
Comment: # (Default JSON response)
Comment: # (Return empty list, which is fine.)
Comment: # (Will be populated based on type)
Comment: # (For consistency if client uses submitted_answer)
Comment: # (For single_choice etc.)
Comment: # (Catch potential errors during user fetch)
Comment: # (使用 model_validate)
Comment: # (No specific try-except for the list comprehension part...)
Comment: # (此部分仅在直接通过 `python app/main.py` (或类似方式) 运行此文件时执行。)
Comment: # (settings not loaded)
Comment: # (Uvicorn的访问日志已通过core.config中的日志配置进行管理)

---
File: app/models/__init__.py
Comment: # (app.models package initialization file.) (Docstring)
Comment: # (This package centralizes all Pydantic data models in the application...) (Docstring)
Comment: # (e.g.): `from app.models import UserCreate, Token, ExamPaperResponse`
Comment: # (Explicitly import models from submodules to avoid F403 and F405 errors from ruff/pyflakes and to make it clear what is being exported.)
Comment: # (Not defined in paper_models.py) (appears twice)
Comment: # (Enum) (appears twice)
Comment: # (This is a model, not QuestionBankContent or QuestionBankMetadata directly)
Comment: # (This is a concept, represented by QuestionBank.questions)
Comment: # (This is a concept, represented by QuestionBank.metadata (which is LibraryIndexItem))
Comment: # (Not defined as a separate enum in qb_models.py, part of QuestionModel)
Comment: # (Added) (referring to UserDirectoryEntry)
Comment: # (Not actually defined in user_models.py, removed from import and __all__)
Comment: # (Ensure this is defined in paper_models.py if exported) (appears twice)
Comment: # (If it's a separate Enum)
Comment: # (Represents the full bank with metadata and questions)
Comment: # (Removed as it's not defined)
Comment: # (Dynamically clean up __all__ to ensure no undefined names are listed, though with explicit imports this should be less of an issue.)

---
File: app/models/audit_log_models.py
Comment: # (Pydantic Models Module for Audit Logs.) (Docstring)
Comment: # (This module defines data models for representing audit log entries...) (Docstring)
Comment: # (Pydantic model for an audit log entry.) (Docstring for AuditLogEntry)
Comment: # (Unique ID for the event)
Comment: # (Timestamp of when the event occurred (UTC))
Comment: # (UID of the user performing the action)
Comment: # (IP address of the user performing the action)
Comment: # (Type of action performed)
Comment: # (Type of the target resource)
Comment: # (ID of the target resource)
Comment: # (Status of the action outcome)
Comment: # (Additional details related to the event)
Comment: # (Ensure datetime is serialized to ISO format)

---
File: app/models/config_models.py
Comment: # (Pydantic Models Module for Application Configuration.) (Docstring)
Comment: # (This module defines Pydantic models for API request and response bodies, primarily related to the application's configuration settings (settings.json)...) (Docstring)
Comment: # (Module Imports)
Comment: # (Import the new enum)
Comment: # (Payload Models for Configuration Sub-structures)
Comment: # (These models are used within SettingsUpdatePayload and SettingsResponseModel to represent configurable sub-sections.)
Comment: # (Payload/Response model for rate limit configuration.) (Docstring for RateLimitConfigPayload)
Comment: # (Max requests in time window)
Comment: # (Time window size in seconds)
Comment: # (Payload/Response model for rate limit configurations of a specific user type.) (Docstring for UserTypeRateLimitsPayload)
Comment: # (Rate limit for get_exam endpoint)
Comment: # (Rate limit for auth attempts)
Comment: # (Payload/Response model for Cloudflare IP range fetching configuration.) (Docstring for CloudflareIPsConfigPayload)
Comment: # (Cloudflare IPv4 list URL)
Comment: # (Cloudflare IPv6 list URL)
Comment: # (Auto-update interval in seconds)
Comment: # (Payload/Response model for JSON database file path configuration.) (Docstring for DatabaseFilesConfigPayload)
Comment: # (Filename for paper data)
Comment: # (Filename for user data)
Comment: # (Payload/Response model for user registration validation rule configuration.) (Docstring for UserValidationConfigPayload)
Comment: # (Min username length)
Comment: # (Max username length)
Comment: # (Min password length)
Comment: # (Max password length)
Comment: # (Username regex)
Comment: # (Pydantic model for representing application configuration in API responses (e.g., when an admin fetches settings)...) (Docstring for SettingsResponseModel)
Comment: # (Application name)
Comment: # (Token expiry in hours)
Comment: # (Token byte length)
Comment: # (Default questions per paper)
Comment: # (Number of correct choices to select)
Comment: # (Number of incorrect choices to select)
Comment: # (Random code byte length)
Comment: # (Passing score percentage)
Comment: # (DB persistence interval in seconds)
Comment: # (Rate limit configurations)
Comment: # (Cloudflare IP fetching config)
Comment: # (Log filename)
Comment: # (Use the enum type)
Comment: # (Application log level)
Comment: # (JSON database filename config)
Comment: # (Question library folder path)
Comment: # (Question library index filename)
Comment: # (User validation rule config)
Comment: # (Enable Uvicorn access log)
Comment: # (Enable debug mode (mainly for uvicorn reload))
Comment: # (Ignore extra fields from settings.json)
Comment: # (Pydantic request body model used when an admin updates application configuration. All fields are optional, allowing admins to update only a subset of config items.) (Docstring for SettingsUpdatePayload)
Comment: # (Token expiry in hours (must be >= 1))
Comment: # (Database file path config)
Comment: # (Question library folder path (relative to data dir))
Comment: # (Enable debug mode)
Comment: # (Forbid unknown fields on update)
Comment: # (This module should not be executed as the main script. It defines Pydantic models related to application configuration.)
Comment: # (This module ({__name__}) defines Pydantic models related to application configuration and should not be executed directly.)

---
File: app/models/enums.py
Comment: # (Shared Enumeration Types Module.) (Docstring)
Comment: # (This module defines enumeration types that may be reused by multiple modules across the application.) (Docstring)
Comment: # (Log Level Enumeration.) (Docstring for LogLevelEnum)
Comment: # (Paper Pass Status Enumeration.) (Docstring for PaperPassStatusEnum)
Comment: # (- `PASSED`: Passed the exam. - `FAILED`: Failed the exam...)
Comment: # (Passed)
Comment: # (Failed)
Comment: # (Grading in progress - if async/manual grading is needed)
Comment: # (Pending submission or grading)
Comment: # (Objective part graded, subjective pending review)
Comment: # (More statuses like CANCELED, ERROR_IN_GRADING can be added as needed)
Comment: # (Question Type Enumeration.) (Docstring for QuestionTypeEnum)
Comment: # (Defines various question types supported in the system: - `single_choice`: Single choice... - `essay_question`: Essay/subjective question...)
Comment: # (Single Choice)
Comment: # (Multiple Choice - future support)
Comment: # (Fill-in-the-blank - future support)
Comment: # (Essay Question - future support)
Comment: # (API Status Code Enumeration for Authentication.) (Docstring for AuthStatusCodeEnum)
Comment: # (Success Types)
Comment: # (General authentication success)
Comment: # (Client Error Types)
Comment: # (Incorrect username or password)
Comment: # (Username already exists)
Comment: # (Token is invalid or expired)
Comment: # (User account inactive or banned)
Comment: # (Server errors usually use HTTP 5xx and might not be defined here)
Comment: # (This module ({__name__}) defines shared enumeration types and should not be executed directly.)

---
File: app/models/paper_models.py
Comment: # (Pydantic Models Module for Exam Papers and Submissions.) (Docstring)
Comment: # (This module defines the data structures required for functionalities such as paper creation, submission, grading, history viewing, etc...) (Docstring)
Comment: # (Module Imports)
Comment: # (Fixed F821: For PaperQuestionInternalDetail.internal_question_id default_factory)
Comment: # (UUID from typing is also available, but direct import of uuid module is common for uuid.uuid4())
Comment: # (Import DifficultyLevel enum)
Comment: # (Main App API Models - Paper & Submission Related)
Comment: # (Structure for a single question in the /get_exam response (client-facing).) (Docstring for ExamQuestionClientView)
Comment: # (Question body.)
Comment: # (Options for multiple-choice questions (map of ID to text, shuffled).)
Comment: # (Question type.)
Comment: # (Request body model for user submitting a paper or updating progress.) (Docstring for PaperSubmissionPayload)
Comment: # (Unique identifier for the paper.)
Comment: # (List of selected option IDs, corresponding sequentially to each question's answer. For unanswered questions, send null or an empty string.)
Comment: # (Response model for the GET /get_exam endpoint. Used to return a newly created paper or an unfinished paper resumed by the user.) (Docstring for ExamPaperResponse)
Comment: # (Unique identifier of the paper (UUID string).)
Comment: # (Difficulty level of the paper.)
Comment: # (List of paper questions.)
Comment: # (Response model for the POST /finish endpoint, representing the paper grading result.) (Docstring for GradingResultResponse)
Comment: # (Textual status description (e.g., 'PASSED', 'FAILED', 'ALREADY_GRADED').)
Comment: # (Optional accompanying message for the operation result.)
Comment: # (Passcode generated if the exam is passed (optional).)
Comment: # (Raw score (number of correctly answered questions).)
Comment: # (Percentage score (0-100).)
Comment: # (If the paper was previously graded, this field indicates the prior status.)
Comment: # (Number of subjective questions pending manual grading. If 0 or None, all questions are graded.)
Comment: # (Response model for the POST /update endpoint, representing the paper progress saving result.) (Docstring for UpdateProgressResponse)
Comment: # (Custom business status code.)
Comment: # (Textual status description (e.g., 'PROGRESS_SAVED').)
Comment: # (Operation result message.)
Comment: # (Related paper ID.)
Comment: # (ISO formatted string of the last update time.)
Comment: # (History API Models)
Comment: # (Summary information for a single paper in the user's history list (GET /history endpoint).) (Docstring for HistoryItem)
Comment: # (Difficulty level of the paper.)
Comment: # (Raw score (if graded).)
Comment: # (Percentage score (if graded).)
Comment: # (Pass status ('PASSED', 'FAILED', or null).)
Comment: # (ISO formatted string of submission time (if submitted).)
Comment: # (Structure for a single question in the GET /history_paper endpoint (client-facing).) (Docstring for HistoryPaperQuestionClientView)
Comment: # (Options for multiple-choice questions (map of ID to text, shuffled).)
Comment: # (User's submitted answer: option ID(s) for choice, list of texts for fill-in-blank, text for subjective.)
Comment: # (Student's submitted text answer if it's a subjective question.)
Comment: # (Standard answer/key points for subjective questions, if student viewing is allowed.)
Comment: # (Manual score for this subjective question.)
Comment: # (Teacher's comment on this subjective question.)
Comment: # (Response model for the GET /history_paper endpoint, for detailed information of a specific historical paper.) (Docstring for HistoryPaperDetailResponse)
Comment: # (UID of the user who took this paper.)
Comment: # (List of paper questions and user's answers.)
Comment: # (Total raw score (if fully graded).)
Comment: # (Total percentage score (if fully graded).)
Comment: # (User's complete original answer card (list of option IDs, null for unanswered).)
Comment: # (Final pass status.)
Comment: # (Passcode (if passed).)
Comment: # (Paper submission time.)
Comment: # (Total number of subjective questions in the paper.)
Comment: # (Number of manually graded subjective questions.)
Comment: # (Admin API Models - Paper Related)
Comment: # (Summary information model for a single paper in the GET /admin/paper/all endpoint.) (Docstring for PaperAdminView)
Comment: # (Paper ID.)
Comment: # (User UID.)
Comment: # (Creation time (UTC).)
Comment: # (Creation IP address.)
Comment: # (Paper difficulty.)
Comment: # (Total number of questions in this paper.)
Comment: # (Number of questions answered by the user.)
Comment: # (Number of questions answered correctly by the user (same as graded score).)
Comment: # (Raw score.)
Comment: # (Percentage score.)
Comment: # (Submission time (UTC).)
Comment: # (Submission IP address.)
Comment: # (Pass status.)
Comment: # (Passcode.)
Comment: # (Last update time (UTC).)
Comment: # (Last update IP address.)
Comment: # (Internal storage structure for a single question within the `paper_questions` field. Includes question content, choice answer mappings, and subjective question answering/grading info.) (Docstring for PaperQuestionInternalDetail)
Comment: # (Unique internal ID for this question within the paper.)
Comment: # (Correct choices (ID -> text) for choice questions.)
Comment: # (Incorrect choices (ID -> text) for choice questions.)
Comment: # (Question type (e.g., 'single_choice', 'essay_question').)
Comment: # (Reference answer for subjective questions.)
Comment: # (Scoring criteria for subjective questions.)
Comment: # (General answer explanation or reference information.)
Comment: # (Student's submitted text answer for subjective questions.)
Comment: # (Manual score for this subjective question.)
Comment: # (Teacher's comment on this subjective question.)
Comment: # (Whether this subjective question has been manually graded.)
Comment: # (Response model for GET /admin/paper/?paper_id={paper_id} endpoint, for full details of a specific paper.) (Docstring for PaperFullDetailModel)
Comment: # (List of original paper questions (with answer mappings).)
Comment: # (Models for Grading Subjective Questions)
Comment: # (Item model for the list of papers pending manual grading.) (Docstring for PendingGradingPaperItem)
Comment: # (Total subjective questions.)
Comment: # (Pending subjective questions.)
Comment: # (Data model for a single question when fetching subjective questions for grading.) (Docstring for SubjectiveQuestionForGrading)
Comment: # (Internal unique ID of the question in the paper.)
Comment: # (Question type (should be essay_question).)
Comment: # (Student's submitted text answer.)
Comment: # (Standard answer or key points.)
Comment: # (Scoring criteria.)
Comment: # (Current saved manual score.)
Comment: # (Current saved teacher comment.)
Comment: # (Whether this question has been graded.)
Comment: # (Request body model for submitting the grading result of a single subjective question.) (Docstring for GradeSubmissionPayload)
Comment: # (Manually assigned score (non-negative).)
Comment: # (Teacher's comment (optional, max 1000 chars).)
Comment: # (This module should not be executed as the main script. It defines Pydantic models related to exam papers and submissions.)
Comment: # (This module ({__name__}) defines Pydantic models related to exam papers and submissions and should not be executed directly.)

---
File: app/models/qb_models.py
Comment: # (Pydantic Models Module for Question Banks.) (Docstring)
Comment: # (This module defines data models for representing question bank items, question bank index metadata, and the overall structure of a question bank...) (Docstring)
Comment: # (Module Imports)
Comment: # (Model for a single question in the question bank.) (Docstring for QuestionModel)
Comment: # (Used for file storage, GET responses in Admin API (as a list element), and POST request bodies (when adding new questions)...)
Comment: # (Question body; for fill-in-the-blank, use {blank} for blanks.)
Comment: # (Use enum type)
Comment: # (Use enum members as default value)
Comment: # (Question type.)
Comment: # (Multiple-choice related fields)
Comment: # (List of correct answer option texts for choice-based questions. Should be None for subjective questions.)
Comment: # (List of incorrect answer option texts for choice-based questions. Should be None for subjective questions.)
Comment: # (For multiple-choice questions, indicates the number of correct answers to select; usually 1 for single-choice. Should be None for subjective questions.)
Comment: # (Fill-in-the-blank related fields)
Comment: # (List of correct filling answer texts for fill-in-the-blank questions (can include wildcards, e.g., '?'). Should be None for other question types.)
Comment: # (Subjective/Essay Question related fields)
Comment: # (Reference answer or key points for subjective questions. For teacher grading reference or student review. Should be None for non-subjective questions.)
Comment: # (Scoring criteria or detailed rubrics for subjective questions. For teacher grading reference. Should be None for non-subjective questions.)
Comment: # (General Reference/Explanation field)
Comment: # (This field can be used for all question types to provide additional explanations, solution approaches, or links to knowledge points.)
Comment: # (General answer explanation or reference information (optional). E.g., explanation for multiple-choice answers, or supplementary notes for subjective questions.)
Comment: # (Validates that choice text (if provided) is not empty or whitespace-only.) (Docstring for _validate_choice_text)
Comment: # (Option at index {item_idx} in field '{info.field_name}' cannot be empty or whitespace.)
Comment: # (Validates that fill-in-the-blank answer text (if provided) is not empty or whitespace-only.) (Docstring for _validate_filling_text)
Comment: # (Filling answer at index {item_idx} cannot be empty or whitespace.)
Comment: # (Pydantic V2+ handles enum validation automatically when the type hint is QuestionTypeEnum. The custom validator _validate_question_type is no longer needed.)
Comment: # (LibraryIndexItem Model)
Comment: # (Metadata model for a single question bank in the library index file (`index.json`).) (Docstring for LibraryIndexItem)
Comment: # (Unique ID of the bank (usually corresponds to filename, e.g., 'easy').)
Comment: # (Display name of the bank (e.g., 'Simple Difficulty').)
Comment: # (Detailed description of the bank.)
Comment: # (Default number of questions when generating a paper from this bank.)
Comment: # (Actual total number of questions in this bank (usually updated dynamically).)
Comment: # (Validates if the ID is a valid DifficultyLevel value. Current implementation requires ID to be one of DifficultyLevel.) (Docstring for id_must_be_valid_difficulty_or_custom)
Comment: # (Try converting to DifficultyLevel enum member)
Comment: # (Bank ID '{v}' is not a valid predefined difficulty level. Valid levels)
Comment: # (QuestionBank Model) - 用于API响应或内部聚合
Comment: # (Represents a complete question bank, including its metadata and list of all questions. Mainly used for API responses, e.g., when an admin fetches the entire content of a bank.) (Docstring for QuestionBank)
Comment: # (Metadata information of the bank.)
Comment: # (List of all questions in the bank.)
Comment: # (Validates if `total_questions` in metadata matches the actual length of the questions list.) (Docstring for check_total_questions_match)
Comment: # (total_questions ({self.metadata.total_questions}) in metadata for bank '{self.metadata.id}' does not match actual questions count ({len(self.questions)}). Consider fixing in CRUD layer.)
Comment: # (Actual correction is usually done in the CRUD layer; model layer primarily for validation and warnings.)
Comment: # (Optional: model layer self-correction)
Comment: # (This module should not be executed as the main script. It defines Pydantic models related to question banks.)
Comment: # (This module ({__name__}) defines Pydantic models related to question banks and should not be executed directly.)

---
File: app/models/token_models.py
Comment: # (Pydantic Models Module for Tokens and Authentication Status.) (Docstring)
Comment: # (This module defines data structures used in the API authentication process, such as: - `Token`: Standard response body returned after successful login or token refresh...) (Docstring)
Comment: # (Module Imports)
Comment: # (Import UserTag enum)
Comment: # (Token Model)
Comment: # (API Token model, used as the standard response body for successful login and token refresh. Conforms to the common structure of an OAuth 2.0 Bearer Token response.) (Docstring for Token)
Comment: # (Access token (usually a long, randomly generated string).)
Comment: # (Token type, fixed as 'bearer'.)
Comment: # (Can add fields like expires_in (seconds) or user_info, etc.)
Comment: # (e.g., return user info upon successful login)
Comment: # (TokenData Model)
Comment: # (Data model carried by a token when stored internally or after parsing. If using JWT, this can represent the payload part of the JWT...) (Docstring for TokenData)
Comment: # (Associated user's unique identifier (uid).)
Comment: # (List of tags possessed by the user, for permission control.)
Comment: # (Token's expiration timestamp (float representation of time.time()).)
Comment: # (Can add other information needed for quick access in the token, such as issued-at time (iat), etc.)
Comment: # (Auth Status Response Model)
Comment: # (Generic model for authentication failure or specific status responses.) (Docstring for AuthStatusResponse)
Comment: # (Use enum type)
Comment: # (Code representing authentication result or specific status.)
Comment: # (Related message text (optional).)
Comment: # (This module should not be executed as the main script. It defines Pydantic models related to tokens and authentication status.)
Comment: # (This module ({__name__}) defines Pydantic models related to tokens and authentication status and should not be executed directly.)

---
File: app/models/user_models.py
Comment: # (Pydantic Models Module for User-related Data.) (Docstring)
Comment: # (This module defines data structures required for handling user accounts, authentication, profiles, and administrative operations...) (Docstring)
Comment: # (Module Imports)
Comment: # (For regular expression validation)
Comment: # (Import global settings)
Comment: # (UserTag Enum)
Comment: # (User tag enum, defining permission levels for different user roles.) (Docstring for UserTag)
Comment: # (Admin: Highest privileges)
Comment: # (Regular user)
Comment: # (Banned user)
Comment: # (Limited user with stricter rate limits)
Comment: # (Grader for subjective questions)
Comment: # (Question creator/bank admin)
Comment: # (Operational manager)
Comment: # (Gets the default list of tags for new users.) (Docstring for get_default_tags)
Comment: # (UserBase Model)
Comment: # (Base model for user information, used in API request bodies and as a base for other user models.) (Docstring for UserBase)
Comment: # (Username ({settings.user_config.uid_min_len}-{settings.user_config.uid_max_len} chars, lowercase letters, numbers, or underscores only).)
Comment: # (User nickname (optional, max 50 chars).)
Comment: # (Email (optional, must be a valid email format).)
Comment: # (QQ number (optional, 5-15 digits).)
Comment: # (Renamed validator for clarity)
Comment: # (Validates if UID conforms to the regex and length defined in settings.) (Docstring for uid_must_match_regex_and_length)
Comment: # (Username length must be between {uid_config.uid_min_len} and {uid_config.uid_max_len}.)
Comment: # (Username can only contain lowercase letters, numbers, or underscores.)
Comment: # (UserCreate Model)
Comment: # (Model used for user registration, inherits from UserBase and adds a password field.) (Docstring for UserCreate)
Comment: # (Password ({settings.user_config.password_min_len}-{settings.user_config.password_max_len} chars).)
Comment: # (UserProfileUpdate Model)
Comment: # (Model used when a user updates their profile, all fields are optional.) (Docstring for UserProfileUpdate)
Comment: # (New user nickname (optional).)
Comment: # (New email (optional).)
Comment: # (New QQ number (optional).)
Comment: # (UserPasswordUpdate Model)
Comment: # (Model used when a user updates their password.) (Docstring for UserPasswordUpdate)
Comment: # (Current password.)
Comment: # (New password ({settings.user_config.password_min_len}-{settings.user_config.password_max_len} chars).)
Comment: # (UserInDBBase and UserInDB Models)
Comment: # (Base model for users stored in the database, adds tags to UserBase.) (Docstring for UserInDBBase)
Comment: # (List of user tags, determining permissions and behavior.)
Comment: # (Pydantic v2 orm_mode equivalent)
Comment: # (Complete model for users stored in the database, inherits from UserInDBBase and adds hashed password.) (Docstring for UserInDB)
Comment: # (Hashed user password.)
Comment: # (UserPublicProfile Model)
Comment: # (Public user information model returned to clients in API responses. Excludes sensitive info like passwords.) (Docstring for UserPublicProfile)
Comment: # (List of user tags.)
Comment: # (AdminUserUpdate Model)
Comment: # (Model used when an admin edits user information. Allows modification of more fields.) (Docstring for AdminUserUpdate)
Comment: # ((Optional) Set a new password for the user ({settings.user_config.password_min_len}-{settings.user_config.password_max_len} chars). Overwrites existing password if provided.)
Comment: # (UserDirectoryEntry Model)
Comment: # (Model for listing users with special roles in a public directory.) (Docstring for UserDirectoryEntry)
Comment: # (User ID (username).)
Comment: # (User nickname (if available).)
Comment: # (User tags indicating their roles/categories.)
Comment: # (This module should not be executed as the main script. It defines Pydantic models related to users.)
Comment: # (This module ({__name__}) defines Pydantic models related to users and should not be executed directly.)

---
File: app/services/__init__.py
Comment: # Example placeholder (appears twice)

---
File: app/services/audit_logger.py
Comment: # (Audit Logging Service Module.) (Docstring)
Comment: # (This module provides a service class for logging important actions and events within the application to an audit log file...) (Docstring)
Comment: # (Path to the audit log file, read from configuration)
Comment: # (Assuming settings.audit_log_file_path will be "data/logs/audit.log")
Comment: # (Audit Logging Service class.) (Docstring for AuditLoggerService)
Comment: # (Responsible for initializing a dedicated audit logger and providing a method to log structured audit events.)
Comment: # (Singleton pattern might be useful here if multiple instantiations are a concern, but a global instance is also fine for this project structure.)
Comment: # (For simplicity, we'll use a global instance approach rather than enforcing singleton here.)
Comment: # (Initializes the audit logger.) (Docstring for __init__)
Comment: # (- Ensure audit log directory exists. - Set up a Python logger named "audit_log"...)
Comment: # (Ensure this runs only once for the global instance)
Comment: # (Avoid adding multiple handlers if instantiated multiple times (though global instance should prevent this))
Comment: # (Ensure log directory exists)
Comment: # (Use a fallback logger or print if this critical setup fails)
Comment: # (Depending on policy, could raise error or continue without file logging for audit)
Comment: # (For now, it will try to add handler anyway, which might fail if dir doesn't exist)
Comment: # (Custom formatter to output the message directly)
Comment: # (record.msg should be the JSON string)
Comment: # (Prevent audit logs from propagating to the root logger if it has other handlers (e.g. console))
Comment: # (Logs an audit event.) (Docstring for log_event)
Comment: # (Generate timestamp at the moment of logging)
Comment: # (Convert Pydantic model to JSON string using model_dump_json())
Comment: # (Log the JSON string using the configured audit logger)
Comment: # (If audit logging itself fails, log to the main app logger or stderr)
Comment: # (Failed audit event data)
Comment: # (Create a global instance of the audit logging service)

---
File: app/services/websocket_manager.py
Comment: # (WebSocket Connection Management Module.) (Docstring)
Comment: # (This module provides a `WebSocketManager` class for managing active WebSocket connections and supports broadcasting messages to all connected clients...) (Docstring)
Comment: # (List for potential future use with multiple rooms)
Comment: # (Get logger instance for this module)
Comment: # (Class for managing WebSocket connections.) (Docstring for WebSocketManager)
Comment: # (Provides functionalities for connecting, disconnecting, and broadcasting messages.)
Comment: # (Initializes the WebSocketManager.) (Docstring for __init__)
Comment: # (A set storing all currently active WebSocket connections.)
Comment: # (An asyncio.Lock to protect `active_connections` during concurrent operations.)
Comment: # (WebSocketManager initialized.)
Comment: # (Handles a new WebSocket connection.) (Docstring for connect)
Comment: # (Adds the new WebSocket object to the set of active connections.)
Comment: # (The FastAPI WebSocket object to add.)
Comment: # (Accept the WebSocket connection)
Comment: # (Get client info for logging)
Comment: # (WebSocket connected: {client_host}:{client_port}. Total connections: {len(self.active_connections)}.)
Comment: # (Handles a WebSocket disconnection.) (Docstring for disconnect)
Comment: # (Removes the specified WebSocket object from the set of active connections.)
Comment: # (The FastAPI WebSocket object to remove.)
Comment: # (WebSocket disconnected: {client_host}:{client_port}. Remaining connections: {len(self.active_connections)}.)
Comment: # (The WebSocket object is typically closed by FastAPI itself after disconnection, no explicit call to websocket.close() is needed here.)
Comment: # (Broadcasts a JSON message to all currently connected WebSocket clients.) (Docstring for broadcast_message)
Comment: # (If an exception occurs while sending a message to a client (e.g., connection closed), that client will be safely removed.)
Comment: # (The JSON-serializable dictionary message to broadcast.)
Comment: # (Create a copy of current connections for iteration to allow safe modification of the original set during broadcasting.)
Comment: # (Use lock to ensure integrity of connection list during copy and iteration)
Comment: # (Collect all still active connections for broadcasting)
Comment: # (This is important because a connection might have been closed right before acquiring the lock)
Comment: # (Broadcast message: No active connections, message not sent.)
Comment: # (WebSocketException, ConnectionClosed, etc.)
Comment: # (Client might have disconnected)
Comment: # (Failed to broadcast message to {client_host}:{client_port}: {e}. Marking connection for removal.)
Comment: # (If any connections failed during broadcast, remove them from the main list)
Comment: # (Check again, in case state changed between lock acquisitions)
Comment: # (Create a global instance of WebSocketManager)

---
File: app/utils/__init__.py
Comment: # (Region 包初始化) - This is Chinese, "包初始化" means "Package Initialization"
Comment: # (重命名以更清晰地表明长度参数是字节数) - This is Chinese, "Rename to more clearly indicate that the length parameter is in bytes"
Comment: # (重命名以更清晰地表明它需要 Request 对象) - This is Chinese, "Rename to more clearly indicate that it requires a Request object"

---
File: app/utils/export_utils.py
Comment: # (Data Export Utilities Module) (Docstring)
Comment: # (This module provides utility functions for exporting data to CSV and XLSX formats. It's primarily intended for use in API endpoints to offer file downloads as streaming responses.) (Docstring)
Comment: # (For XLSX export)
Comment: # (Converts a list of dictionaries to CSV format and provides it for download via StreamingResponse.) (Docstring for data_to_csv)
Comment: # (Data to export, each dict represents a row, keys should match headers.)
Comment: # (List of headers for the CSV file.)
Comment: # (Suggested filename for the download.)
Comment: # (FastAPI StreamingResponse object containing the CSV data.)
Comment: # (Use utf-8-sig for Excel to correctly display Chinese chars)
Comment: # (The StreamingResponse will handle encoding, but csv.writer needs unicode.)
Comment: # (Write headers)
Comment: # (Write data rows)
Comment: # (Safely get values)
Comment: # (The content must be bytes for StreamingResponse if we specify charset in media_type or headers)
Comment: # (For simplicity with csv.writer producing strings, we'll let StreamingResponse handle it.)
Comment: # (Reset stream position)
Comment: # (Create a string iterator for StreamingResponse)
Comment: # (This avoids loading the whole CSV into memory as one giant string if data_list is huge.)
Comment: # (However, csv.writer already wrote to an in-memory StringIO buffer.)
Comment: # (For very large datasets, a different approach might be needed (e.g. generating CSV row by row as an iterator).)
Comment: # (Given the current structure with StringIO, we'll read its content.)
Comment: # (StringIO doesn't need explicit close for getvalue())
Comment: # (Encode to utf-8-sig for BOM)
Comment: # (Explicitly state encoding for clarity, though BOM handles it)
Comment: # (Converts a list of dictionaries to XLSX format and provides it for download via StreamingResponse.) (Docstring for data_to_xlsx)
Comment: # (Data to export, each dict represents a row.)
Comment: # (List of headers for the XLSX file.)
Comment: # (Suggested filename for the download.)
Comment: # (FastAPI StreamingResponse object containing the XLSX data.)
Comment: # (Save workbook to an in-memory byte stream)
Comment: # (BytesIO is directly iterable by StreamingResponse)

---
File: app/utils/helpers.py
Comment: # (General Utility Functions Module) (Docstring)
Comment: # (This module contains auxiliary functions that may be reused in multiple places in the project, such as time formatting, UUID abbreviation, client IP address acquisition, data structure processing, and random string generation.) (Docstring)
Comment: # (Module Imports)
Comment: # (For processing and validating IP addresses)
Comment: # (For generating cryptographically strong random numbers)
Comment: # (Type hinting)
Comment: # (For type hinting)
Comment: # (Request object for client IP and headers)
Comment: # (Global Variables & Initialization)
Comment: # (Get logger instance for this module)
Comment: # (Time & UUID Formatting Utilities)
Comment: # (Get a formatted string of the current time.) (Docstring for get_current_timestamp_str)
Comment: # (Current time string in "YYYY-MM-DD HH:MM:SS" format.)
Comment: # (Formats a UUID object or string into an abbreviated form "first_four....last_four" for easier log viewing.) (Docstring for format_short_uuid)
Comment: # (UUID object or its string representation.)
Comment: # (Formatted UUID string, or the original string if it's too short.)
Comment: # (Ensure UUID string is long enough for abbreviation)
Comment: # (IP Address Acquisition Utilities)
Comment: # (Gets the client's real IP address from FastAPI's Request object. If the request appears to be from Cloudflare (based on the provided CIDR lists), CF-related headers are trusted preferentially. Otherwise, the direct connecting IP is used.) (Docstring for get_client_ip_from_request)
Comment: # (FastAPI Request object.)
Comment: # ((Optional) List of Cloudflare's IPv4 CIDR ranges.)
Comment: # ((Optional) List of Cloudflare's IPv6 CIDR ranges.)
Comment: # (Identified client IP address string, or "Unknown" if it cannot be determined.)
Comment: # (Attempt to get from common reverse proxy headers, but use with caution as they can be spoofed)
Comment: # (X-Forwarded-For may contain multiple IPs, take the leftmost one (usually original client))
Comment: # (Truly unable to get any IP info)
Comment: # (Try to convert the obtained direct IP to an ipaddress object for validation and comparison)
Comment: # (Check if the direct connecting IP is within known Cloudflare ranges)
Comment: # (If connection is from Cloudflare, trust Cloudflare-set headers)
Comment: # (Validate if it's a valid IP format)
Comment: # (Validate)
Comment: # (Last resort: return CF's connecting IP)
Comment: # (If not from Cloudflare, don't trust proxy headers, use request.client.host directly)
Comment: # (Data Structure & Random Generation Utilities)
Comment: # (Creates a new dictionary whose items have a random insertion order. Relies on the behavior of Python 3.7+ where dictionary order is insertion order.) (Docstring for shuffle_dictionary_items)
Comment: # (Input dictionary whose items need to be shuffled.)
Comment: # (A new dictionary with the same items as input_dict, but in random order.)
Comment: # (If the input is not a dictionary.)
Comment: # (Input must be a dictionary.)
Comment: # (Shuffle list in-place)
Comment: # (Create new dict from shuffled list)
Comment: # (Generates a random lowercase hexadecimal string of a specified byte length. The final hexadecimal string length will be twice length_bytes.) (Docstring for generate_random_hex_string_of_bytes)
Comment: # (Number of random bytes to generate.)
Comment: # (A random lowercase hexadecimal string.)
Comment: # (If length_bytes is less than 1.)
Comment: # (Byte length must be at least 1.)
Comment: # (Generate secure random bytes)
Comment: # (Convert bytes to lowercase hex string)
Comment: # (This module should not be executed as the main script. It defines utility functions that should be imported and used by other modules.)

---
File: app/websocket_routes.py
Comment: # (WebSocket API Routing Module.) (Docstring)
Comment: # (This module defines all API endpoints related to WebSocket communication, for example, for real-time monitoring, notifications, etc.) (Docstring)
Comment: # (For admin permission verification on WebSocket endpoints)
Comment: # (Get logger instance for this module)
Comment: # (Create WebSocket router instance)
Comment: # (Note: FastAPI's behavior for `dependencies` on APIRouter with WebSockets might be limited. Typically, WebSocket authentication is handled within the endpoint function during connection establishment using query parameters or headers. Adding `Depends(require_admin)` here declares intent; actual execution might require adjustments.)
Comment: # (Attempt to apply admin authentication to the entire router)
Comment: # (Exam Monitoring WebSocket Endpoint.) (Docstring for websocket_exam_monitor)
Comment: # (Administrator clients can connect via this endpoint to receive real-time exam monitoring information (e.g., examinee submission events).)
Comment: # (A valid admin token must be provided as a query parameter upon connection (e.g., `/ws/exam_monitor?token=YOUR_ADMIN_TOKEN`).)
Comment: # (Actual admin authentication is (attempted) by `Depends(require_admin)` at the APIRouter level...)
Comment: # (Assuming the `require_admin` dependency would reject the connection if failed, or `websocket.scope['user']` would be populated.)
Comment: # (Getting auth info from scope - this is one way FastAPI handles DI, but might differ for WebSockets)
Comment: # (假设依赖注入会填充这个)
Comment: # (Since `require_admin` validates upon connection attempt, if it fails, execution won't reach here. If successful, we can assume the connected client is an authenticated admin.)
Comment: # (Admin client {client_host}:{client_port} connected to exam monitoring WebSocket.)
Comment: # (Admin clients typically only receive messages pushed by the server.)
Comment: # (Here, `receive_text` / `receive_json` is mainly for keeping the connection alive or processing control commands from the client (if designed).)
Comment: # (Received text message from admin client {client_host}:{client_port} on monitoring WebSocket: {data})
Comment: # (Example: if client sends a specific command)
Comment: # (Generally, admin monitoring endpoints don't need to process many regular messages from clients.)
Comment: # (Admin client {client_host}:{client_port} disconnected from exam monitoring WebSocket.)
Comment: # (Log any other exceptions occurring during WebSocket communication)
Comment: # (Exam monitoring WebSocket ({client_host}:{client_port}) encountered an error: {e})
Comment: # (Ensure the connection is removed from the manager regardless of why the loop ended)

---
All identified English comments from .py files in app/ have been listed.
---
